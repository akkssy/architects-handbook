<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Comprehensive C++ Learning Guide - From basics to advanced modern C++, designed for training and industry-standard development">
    <meta name="keywords" content="C++, Modern C++, C++20, C++23, STL, Templates, OOP, Multithreading, Design Patterns, Interview Preparation">
    <meta name="author" content="C++ Mastery Guide">
    <meta property="og:title" content="The C++ Mastery Guide | Complete Learning Resource">
    <meta property="og:description" content="Master C++ from fundamentals to expert level - comprehensive guide with 50+ interview questions, code examples, and industry best practices">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <title>The C++ Mastery Guide | Complete Learning Resource</title>
    <style>
        :root {
            --primary: #0077b6;
            --primary-dark: #005f92;
            --secondary: #7209b7;
            --accent: #f72585;
            --success: #06d6a0;
            --warning: #ffd166;
            --danger: #ef476f;
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-code: #1e1e1e;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border: #dee2e6;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --radius: 12px;
        }
        .dark-mode {
            --primary: #4cc9f0;
            --primary-dark: #4895ef;
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-code: #0d0d0d;
            --text-primary: #e9ecef;
            --text-secondary: #adb5bd;
            --border: #343a40;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: all 0.3s ease;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 20px; }
        /* Header */
        header {
            background: linear-gradient(135deg, #0077b6 0%, #7209b7 50%, #f72585 100%);
            color: white;
            padding: 60px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        .header-content { position: relative; z-index: 1; }
        header h1 { font-size: 3rem; margin-bottom: 15px; font-weight: 800; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        header .cpp-logo { font-size: 4rem; margin-bottom: 15px; display: block; }
        header p { font-size: 1.2rem; opacity: 0.95; max-width: 700px; margin: 0 auto; }
        .header-badges { margin-top: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .header-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.85rem;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.3);
        }
        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 50px;
            padding: 10px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: var(--shadow);
        }
        .theme-toggle:hover { transform: scale(1.05); border-color: var(--primary); }
        /* Navigation */
        nav {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
        }
        .nav-container { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        nav ul { list-style: none; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        nav a {
            color: var(--text-primary);
            text-decoration: none;
            padding: 10px 18px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.95rem;
        }
        nav a:hover { background: var(--primary); color: white; }
        /* Search */
        .search-container { position: relative; }
        .search-input {
            padding: 12px 20px 12px 45px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 0.95rem;
            width: 280px;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s;
        }
        .search-input:focus { outline: none; border-color: var(--primary); width: 320px; }
        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem;
        }
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-top: 8px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .search-results.active { display: block; }
        .search-result-item {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s;
        }
        .search-result-item:hover { background: var(--bg-primary); }
        .search-result-item:last-child { border-bottom: none; }
        .search-result-title { font-weight: 600; color: var(--primary); margin-bottom: 4px; }
        .search-result-context { font-size: 0.85rem; color: var(--text-secondary); }
        /* Progress Section */
        .progress-container {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: var(--radius);
            margin: 30px 0;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }
        .progress-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
        .progress-header h3 { color: var(--primary); display: flex; align-items: center; gap: 10px; }
        .reset-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .reset-btn:hover { opacity: 0.9; transform: scale(1.02); }
        .progress-bar {
            height: 28px;
            background: var(--border);
            border-radius: 14px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            border-radius: 14px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.9rem;
            min-width: 50px;
        }
        .progress-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        .stat-card {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.3s;
        }
        .stat-card:hover { transform: translateY(-3px); border-color: var(--primary); }
        .stat-card h4 { color: var(--primary); font-size: 2rem; margin-bottom: 5px; }
        .stat-card p { color: var(--text-secondary); font-size: 0.9rem; }
        /* Badges */
        .badge {
            display: inline-block;
            padding: 5px 14px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .badge-beginner { background: #d1fae5; color: #065f46; }
        .badge-intermediate { background: #fef3c7; color: #92400e; }
        .badge-advanced { background: #fee2e2; color: #991b1b; }
        .badge-expert { background: #ede9fe; color: #5b21b6; }
        .badge-cpp11 { background: #dbeafe; color: #1e40af; }
        .badge-cpp14 { background: #e0e7ff; color: #3730a3; }
        .badge-cpp17 { background: #fce7f3; color: #9d174d; }
        .badge-cpp20 { background: #ccfbf1; color: #115e59; }
        .badge-cpp23 { background: #fef9c3; color: #854d0e; }
        /* Sections */
        section {
            background: var(--bg-secondary);
            margin: 30px 0;
            padding: 40px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }
        section h2 {
            color: var(--primary);
            font-size: 2rem;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        section h3 {
            color: var(--text-primary);
            font-size: 1.4rem;
            margin: 30px 0 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        section h4 {
            color: var(--secondary);
            font-size: 1.15rem;
            margin: 20px 0 12px;
        }
        /* Collapsible */
        .collapsible {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin: 15px 0;
            overflow: hidden;
            transition: all 0.3s;
        }
        .collapsible:hover { border-color: var(--primary); }
        .collapsible-header {
            padding: 20px 25px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 1.1rem;
            transition: background 0.3s;
        }
        .collapsible-header:hover { background: var(--border); }
        .collapsible-header .header-left { display: flex; align-items: center; gap: 12px; flex: 1; }
        .collapsible-header::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.3s;
            color: var(--text-secondary);
        }
        .collapsible.active .collapsible-header::after { transform: rotate(180deg); }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
            padding: 0 25px;
        }
        .collapsible.active .collapsible-content {
            max-height: 50000px;
            padding: 25px;
            border-top: 1px solid var(--border);
        }
        /* Checklist */
        .checklist { list-style: none; }
        .checklist li {
            padding: 15px 18px;
            margin: 10px 0;
            background: var(--bg-primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s;
            border: 1px solid transparent;
        }
        .checklist li:hover { transform: translateX(5px); border-color: var(--primary); }
        .checklist input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: var(--success);
            flex-shrink: 0;
        }
        .checklist li.completed {
            background: linear-gradient(90deg, #d1fae5, var(--bg-primary));
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        .checklist-label { flex: 1; }
        /* Code Blocks */
        pre {
            background: var(--bg-code);
            color: #d4d4d4;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Cascadia Code', 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            border: 1px solid #333;
            position: relative;
        }
        code {
            font-family: 'Cascadia Code', 'Fira Code', 'Consolas', 'Monaco', monospace;
            background: var(--bg-primary);
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 0.9em;
            color: var(--accent);
        }
        pre code { background: transparent; padding: 0; color: inherit; }
        .code-header {
            background: #2d2d2d;
            color: #888;
            padding: 10px 20px;
            border-radius: 12px 12px 0 0;
            font-size: 0.85rem;
            margin-bottom: -12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .code-header .lang-badge {
            background: var(--primary);
            color: white;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .copy-btn {
            background: transparent;
            border: 1px solid #555;
            color: #888;
            padding: 5px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }
        .copy-btn:hover { background: #444; color: white; }
        /* Syntax Highlighting */
        .keyword { color: #569cd6; }
        .type { color: #4ec9b0; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; font-style: italic; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .preprocessor { color: #c586c0; }
        .operator { color: #d4d4d4; }
        .namespace { color: #4fc1ff; }
        .template { color: #9cdcfe; }
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }
        th, td {
            padding: 16px 20px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        th {
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            color: white;
            font-weight: 600;
        }
        tr:hover { background: var(--bg-primary); }
        /* Tips, Warnings, Info */
        .tip, .warning, .info, .note {
            padding: 20px 25px;
            border-radius: 12px;
            margin: 20px 0;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }
        .tip { background: #d1fae5; border-left: 5px solid var(--success); }
        .warning { background: #fef3c7; border-left: 5px solid var(--warning); }
        .info { background: #dbeafe; border-left: 5px solid var(--primary); }
        .note { background: #ede9fe; border-left: 5px solid var(--secondary); }
        .tip::before { content: 'üí°'; font-size: 1.5rem; }
        .warning::before { content: '‚ö†Ô∏è'; font-size: 1.5rem; }
        .info::before { content: '‚ÑπÔ∏è'; font-size: 1.5rem; }
        .note::before { content: 'üìù'; font-size: 1.5rem; }
        .dark-mode .tip { background: #064e3b; color: #d1fae5; }
        .dark-mode .warning { background: #78350f; color: #fef3c7; }
        .dark-mode .info { background: #1e3a5f; color: #dbeafe; }
        .dark-mode .note { background: #4c1d95; color: #ede9fe; }
        /* Interview Q&A */
        .qa-item {
            background: var(--bg-primary);
            border-radius: var(--radius);
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid var(--border);
        }
        .question {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px 25px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .question::after { content: 'üí°'; font-size: 1.3rem; }
        .answer {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
        }
        .qa-item.active .answer {
            padding: 25px;
            max-height: 5000px;
        }
        /* Video Cards */
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
            margin: 25px 0;
        }
        .video-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: var(--shadow);
        }
        .video-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }
        .video-thumbnail {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            text-align: center;
        }
        .video-thumbnail .play-icon { font-size: 4rem; }
        .video-info { padding: 20px; }
        .video-info h5 { color: var(--text-primary); font-size: 1.05rem; margin-bottom: 10px; }
        .video-info .channel { color: #ff0000; font-size: 0.9rem; font-weight: 600; margin-bottom: 10px; }
        .video-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #ff0000;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
        }
        .video-link:hover { background: #cc0000; }
        .video-section {
            background: linear-gradient(135deg, #fef2f2, #fff);
            border: 2px solid #fecaca;
            border-radius: 16px;
            padding: 25px;
            margin: 30px 0;
        }
        .dark-mode .video-section { background: linear-gradient(135deg, #3c1414, #1e1e1e); border-color: #7f1d1d; }
        .video-section h4 { color: #dc2626; display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        .video-section h4::before { content: '‚ñ∂Ô∏è'; }
        /* Topic Cards */
        .topic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        .topic-card {
            background: var(--bg-primary);
            padding: 25px;
            border-radius: 12px;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }
        .topic-card:hover { border-color: var(--primary); transform: translateY(-5px); }
        .topic-card h5 { color: var(--primary); font-size: 1.1rem; margin-bottom: 12px; }
        .topic-card p { color: var(--text-secondary); font-size: 0.95rem; }
        /* Collapsible */
        .collapsible {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin: 15px 0;
            overflow: hidden;
        }
        .collapsible-header {
            padding: 20px 25px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        .collapsible-header:hover { background: var(--border); }
        .collapsible-header::after { content: '‚ñº'; font-size: 0.8rem; transition: transform 0.3s; }
        .collapsible.active .collapsible-header::after { transform: rotate(180deg); }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            padding: 0 25px;
        }
        .collapsible.active .collapsible-content {
            max-height: 50000px;
            padding: 25px;
            border-top: 1px solid var(--border);
        }
        /* Checklist */
        .checklist { list-style: none; }
        .checklist li {
            padding: 15px 18px;
            margin: 10px 0;
            background: var(--bg-primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .checklist li:hover { transform: translateX(5px); }
        .checklist input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: var(--success);
        }
        .checklist li.completed {
            background: linear-gradient(90deg, #d1fae5, var(--bg-primary));
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        /* Progress */
        .progress-container {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: var(--radius);
            margin: 30px 0;
            box-shadow: var(--shadow);
        }
        .progress-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
        .progress-header h3 { color: var(--primary); }
        .reset-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }
        .progress-bar {
            height: 28px;
            background: var(--border);
            border-radius: 14px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            border-radius: 14px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            min-width: 50px;
        }
        .progress-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        .stat-card {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        .stat-card h4 { color: var(--primary); font-size: 2rem; }
        .stat-card p { color: var(--text-secondary); font-size: 0.9rem; }
        /* Badges */
        .badge {
            display: inline-block;
            padding: 5px 14px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        .badge-beginner { background: #d1fae5; color: #065f46; }
        .badge-intermediate { background: #fef3c7; color: #92400e; }
        .badge-advanced { background: #fee2e2; color: #991b1b; }
        .badge-expert { background: #ede9fe; color: #5b21b6; }
        /* Sections */
        section {
            background: var(--bg-secondary);
            margin: 30px 0;
            padding: 40px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        section h2 {
            color: var(--primary);
            font-size: 2rem;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid var(--primary);
        }
        section h3 { color: var(--text-primary); font-size: 1.4rem; margin: 30px 0 15px; }
        /* Footer */
        footer {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            padding: 50px 20px;
            text-align: center;
            margin-top: 50px;
        }
        footer a { color: #4cc9f0; }
        /* TOC Sidebar */
        .toc-sidebar {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-left: none;
            border-radius: 0 12px 12px 0;
            padding: 15px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 99;
            width: 60px;
            transition: width 0.3s;
        }
        .toc-sidebar:hover { width: 280px; }
        .toc-sidebar:hover .toc-text { display: inline; }
        .toc-text { display: none; margin-left: 10px; }
        .toc-link {
            display: flex;
            align-items: center;
            padding: 10px;
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 8px;
            margin: 5px 0;
        }
        .toc-link:hover { background: var(--primary); color: white; }
        /* Responsive */
        @media (max-width: 768px) {
            header h1 { font-size: 2rem; }
            section { padding: 25px; }
            nav ul { flex-direction: column; align-items: center; }
            .toc-sidebar { display: none; }
        }
        @media print {
            nav, .progress-container, .theme-toggle, .toc-sidebar { display: none; }
            section { break-inside: avoid; }
            .collapsible-content { max-height: none !important; padding: 20px !important; }
        }
    </style>
</head>
<body>
    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark/light mode">
        <span class="theme-icon">üåô</span>
        <span class="theme-text">Dark</span>
    </button>

    <!-- TOC Sidebar -->
    <nav class="toc-sidebar" aria-label="Table of contents">
        <a href="#beginner" class="toc-link">üìó<span class="toc-text">Beginner</span></a>
        <a href="#intermediate" class="toc-link">üìô<span class="toc-text">Intermediate</span></a>
        <a href="#advanced" class="toc-link">üìï<span class="toc-text">Advanced</span></a>
        <a href="#modern-cpp" class="toc-link">üöÄ<span class="toc-text">Modern C++</span></a>
        <a href="#industry" class="toc-link">üè≠<span class="toc-text">Industry</span></a>
        <a href="#interview" class="toc-link">üíº<span class="toc-text">Interview</span></a>
    </nav>

    <!-- Header -->
    <header>
        <div class="header-content">
            <span class="cpp-logo">üî∑</span>
            <h1>The C++ Mastery Guide</h1>
            <p>Your comprehensive journey from C++ fundamentals to expert-level mastery with 100+ code examples and 50+ interview questions.</p>
            <div class="header-badges" style="margin-top: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <span style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 25px; font-size: 0.85rem;">üìö Complete Learning Path</span>
                <span style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 25px; font-size: 0.85rem;">üíª 100+ Code Examples</span>
                <span style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 25px; font-size: 0.85rem;">üíº 50+ Interview Questions</span>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav role="navigation">
        <div class="container" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
            <ul style="list-style: none; display: flex; gap: 8px; flex-wrap: wrap;">
                <li><a href="#cross-language">üîÑ Transition Guide</a></li>
                <li><a href="#beginner">üìó Beginner</a></li>
                <li><a href="#intermediate">üìô Intermediate</a></li>
                <li><a href="#advanced">üìï Advanced</a></li>
                <li><a href="#modern-cpp">üöÄ Modern C++</a></li>
                <li><a href="#industry">üè≠ Industry</a></li>
                <li><a href="#interview">üíº Interview</a></li>
            </ul>
            <div class="search-container" style="position: relative;">
                <span style="position: absolute; left: 15px; top: 50%; transform: translateY(-50%);">üîç</span>
                <input type="text" class="search-input" id="searchInput" placeholder="Search topics..." style="padding: 12px 20px 12px 45px; border: 2px solid var(--border); border-radius: 25px; width: 280px; background: var(--bg-primary); color: var(--text-primary);">
                <div class="search-results" id="searchResults"></div>
            </div>
        </div>
    </nav>

    <main class="container">
        <!-- Progress Tracking -->
        <div class="progress-container">
            <div class="progress-header">
                <h3>üìä Your Learning Progress</h3>
                <button class="reset-btn" onclick="resetProgress()">üîÑ Reset Progress</button>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
            </div>
            <div class="progress-stats">
                <div class="stat-card">
                    <h4 id="completedCount">0</h4>
                    <p>Topics Completed</p>
                </div>
                <div class="stat-card">
                    <h4 id="totalCount">0</h4>
                    <p>Total Topics</p>
                </div>
                <div class="stat-card">
                    <h4 id="beginnerProgress">0%</h4>
                    <p>Beginner</p>
                </div>
                <div class="stat-card">
                    <h4 id="intermediateProgress">0%</h4>
                    <p>Intermediate</p>
                </div>
                <div class="stat-card">
                    <h4 id="advancedProgress">0%</h4>
                    <p>Advanced</p>
                </div>
            </div>
        </div>

        <!-- ==================== CROSS-LANGUAGE TRANSITION SECTION ==================== -->
        <section id="cross-language">
            <h2>üîÑ C++ for Experienced Developers <span class="badge badge-intermediate">Transition Guide</span></h2>

            <div class="note">
                <div><strong>Coming from Java, Python, C#, or JavaScript?</strong> This section explains the fundamental philosophy differences and helps you leverage your existing knowledge while avoiding common pitfalls specific to C++.</div>
            </div>

            <!-- C++ Philosophy -->
            <div class="collapsible active">
                <div class="collapsible-header">
                    <span>üß† The C++ Philosophy: Zero-Cost Abstractions</span>
                </div>
                <div class="collapsible-content">
                    <h4>What Makes C++ Fundamentally Different</h4>
                    <p>C++ follows a core design principle that sets it apart from most modern languages: <strong>"You don't pay for what you don't use, and what you do use, you couldn't hand-code any better."</strong> This philosophy, known as <em>zero-cost abstractions</em>, means:</p>

                    <ul>
                        <li><strong>No hidden runtime overhead:</strong> Unlike Java's JVM or Python's interpreter, C++ compiles directly to machine code</li>
                        <li><strong>Deterministic behavior:</strong> No garbage collector pauses, no JIT compilation warmup</li>
                        <li><strong>Direct hardware access:</strong> Memory addresses, CPU registers, and hardware interfaces are accessible</li>
                        <li><strong>Manual control:</strong> You decide when memory is allocated and freed, not a runtime</li>
                    </ul>

                    <h4>The Trade-off You're Making</h4>
                    <table>
                        <tr>
                            <th>What You Gain</th>
                            <th>What You Give Up</th>
                        </tr>
                        <tr>
                            <td>Predictable, consistent performance</td>
                            <td>Automatic memory management</td>
                        </tr>
                        <tr>
                            <td>Complete control over resources</td>
                            <td>Runtime safety nets (bounds checking by default)</td>
                        </tr>
                        <tr>
                            <td>No runtime dependencies</td>
                            <td>Reflection and runtime type manipulation</td>
                        </tr>
                        <tr>
                            <td>Minimal memory footprint</td>
                            <td>Shorter development time</td>
                        </tr>
                        <tr>
                            <td>True parallelism without GIL</td>
                            <td>Automatic concurrency safety</td>
                        </tr>
                    </table>

                    <div class="info">
                        <div><strong>When to Choose C++:</strong> Game engines, operating systems, embedded systems, high-frequency trading, real-time systems, performance-critical applications, systems where GC pauses are unacceptable.</div>
                    </div>
                </div>
            </div>

            <!-- Memory Model Comparison -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üß± Memory Model: C++ vs Garbage-Collected Languages</span>
                </div>
                <div class="collapsible-content">
                    <h4>The Fundamental Difference</h4>
                    <p>In <strong>Java, Python, C#, and JavaScript</strong>, memory management is automatic. You create objects, and a garbage collector eventually frees them. In <strong>C++</strong>, you have explicit control‚Äîand responsibility‚Äîover every byte.</p>

                    <div class="code-header">
                        <span>Memory Model Comparison</span>
                        <span class="lang-badge">Conceptual</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA/C# (Garbage Collected) ============</span>
<span class="comment">// Object created on heap, GC will clean up "eventually"</span>
<span class="comment">// You have no control over WHEN memory is freed</span>
<span class="comment">// Widget w = new Widget();  // Java</span>
<span class="comment">// w = null;  // Object MIGHT be collected... sometime... maybe</span>

<span class="comment">// ============ PYTHON (Reference Counted + GC) ============</span>
<span class="comment">// w = Widget()  # Reference count = 1</span>
<span class="comment">// w = None      # Reference count = 0, usually freed immediately</span>
<span class="comment">// But circular references need GC intervention</span>

<span class="comment">// ============ C++ (Manual / RAII) ============</span>
<span class="comment">// You choose: stack (automatic) or heap (manual/smart pointer)</span>

<span class="comment">// Stack allocation - automatically destroyed at scope end</span>
{
    Widget w;  <span class="comment">// Created on stack, NO 'new' keyword</span>
}  <span class="comment">// w destroyed HERE, deterministically, immediately</span>

<span class="comment">// Heap allocation - you control the lifetime</span>
Widget* raw = <span class="keyword">new</span> Widget();  <span class="comment">// Allocated on heap</span>
<span class="keyword">delete</span> raw;                   <span class="comment">// YOU must free it - or memory leak!</span>

<span class="comment">// Modern C++ - smart pointers (RAII)</span>
<span class="keyword">auto</span> smart = std::make_unique&lt;Widget&gt;();  <span class="comment">// Heap, auto-freed</span>
<span class="comment">// Freed at end of scope - deterministic like stack, flexible like heap</span>
</code></pre>

                    <h4>Key Insight for GC Language Developers</h4>
                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Critical Mindset Shift:</strong> In C++, <code>new</code> doesn't just create an object‚Äîit creates a <em>responsibility</em>. Every <code>new</code> must have a corresponding <code>delete</code>, or you have a memory leak. Modern C++ solves this with smart pointers (RAII), but understanding the underlying model is essential.</div>
                    </div>

                    <h4>Memory Regions in C++</h4>
                    <table>
                        <tr><th>Region</th><th>Allocation</th><th>Lifetime</th><th>Equivalent in Java/Python</th></tr>
                        <tr><td><strong>Stack</strong></td><td>Automatic</td><td>Until scope ends</td><td>Local primitives in Java; doesn't exist in Python</td></tr>
                        <tr><td><strong>Heap</strong></td><td><code>new</code>/smart ptr</td><td>Until <code>delete</code>/ptr destroyed</td><td>All objects in Java/Python (automatically managed)</td></tr>
                        <tr><td><strong>Static/Global</strong></td><td>At program start</td><td>Entire program</td><td>Static fields in Java; module-level in Python</td></tr>
                    </table>

                    <h4>The RAII Pattern - C++'s Answer to Garbage Collection</h4>
                    <p><strong>RAII (Resource Acquisition Is Initialization)</strong> is the C++ idiom that makes resource management safe without garbage collection. The principle: <em>tie resource lifetime to object lifetime</em>.</p>

                    <div class="code-header">
                        <span>raii_comparison.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA (try-with-resources) ============</span>
<span class="comment">// try (FileInputStream fis = new FileInputStream("file.txt")) {</span>
<span class="comment">//     // use file</span>
<span class="comment">// } // AutoCloseable.close() called</span>

<span class="comment">// ============ PYTHON (context manager) ============</span>
<span class="comment">// with open("file.txt") as f:</span>
<span class="comment">//     # use file</span>
<span class="comment">// # __exit__ called</span>

<span class="comment">// ============ C++ (RAII - built into the language) ============</span>
{
    std::ifstream file(<span class="string">"file.txt"</span>);  <span class="comment">// Resource acquired in constructor</span>
    <span class="comment">// use file</span>
}  <span class="comment">// Destructor called - file closed automatically!</span>

<span class="comment">// RAII works for EVERYTHING - not just files:</span>
{
    std::lock_guard&lt;std::mutex&gt; lock(myMutex);  <span class="comment">// Lock acquired</span>
    <span class="comment">// critical section</span>
}  <span class="comment">// Lock released - even if exception thrown!</span>

{
    std::unique_ptr&lt;Widget&gt; w = std::make_unique&lt;Widget&gt;();
    <span class="comment">// use widget</span>
}  <span class="comment">// Memory freed automatically</span>
</code></pre>

                    <div class="info">
                        <div><strong>üí° Key Insight:</strong> C++'s RAII is <em>more powerful</em> than Java's try-with-resources or Python's context managers because it works automatically for <em>all</em> resources, not just those explicitly placed in a <code>try</code> or <code>with</code> block. Every destructor is a cleanup guarantee.</div>
                    </div>
                </div>
            </div>

            <!-- Value vs Reference Semantics -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üì¶ Value Semantics vs Reference Semantics</span>
                </div>
                <div class="collapsible-content">
                    <h4>The Most Confusing Difference for Java/Python Developers</h4>
                    <p>In Java, Python, and JavaScript, when you write <code>a = b</code> for objects, you're copying a <em>reference</em>‚Äîboth variables point to the same object. In C++, by default, you're copying the <em>entire object</em>.</p>

                    <div class="code-header">
                        <span>value_vs_reference.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="keyword">class</span> <span class="type">Widget</span> {
<span class="keyword">public</span>:
    <span class="keyword">int</span> value = <span class="number">0</span>;
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ JAVA/PYTHON BEHAVIOR (Reference Semantics) ============</span>
    <span class="comment">// Widget a = new Widget();  // Java</span>
    <span class="comment">// Widget b = a;             // b points to SAME object</span>
    <span class="comment">// b.value = 42;             // a.value is ALSO 42!</span>

    <span class="comment">// ============ C++ DEFAULT BEHAVIOR (Value Semantics) ============</span>
    Widget a;
    Widget b = a;       <span class="comment">// COPIES the entire object! b is independent</span>
    b.value = <span class="number">42</span>;       <span class="comment">// a.value is still 0!</span>

    std::cout &lt;&lt; <span class="string">"a.value: "</span> &lt;&lt; a.value &lt;&lt; std::endl;  <span class="comment">// 0</span>
    std::cout &lt;&lt; <span class="string">"b.value: "</span> &lt;&lt; b.value &lt;&lt; std::endl;  <span class="comment">// 42</span>

    <span class="comment">// ============ C++ REFERENCE SEMANTICS (When You Want It) ============</span>
    Widget c;
    Widget& ref = c;    <span class="comment">// ref IS c (alias), not a copy</span>
    ref.value = <span class="number">100</span>;    <span class="comment">// c.value is also 100</span>

    Widget* ptr = &c;   <span class="comment">// ptr points to c</span>
    ptr->value = <span class="number">200</span>;   <span class="comment">// c.value is now 200</span>

    <span class="comment">// ============ VECTORS ARE ALSO VALUE TYPES ============</span>
    std::vector&lt;<span class="keyword">int</span>&gt; vec1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};
    std::vector&lt;<span class="keyword">int</span>&gt; vec2 = vec1;  <span class="comment">// DEEP COPY! All elements copied</span>
    vec2[<span class="number">0</span>] = <span class="number">999</span>;              <span class="comment">// vec1[0] is still 1</span>

    <span class="comment">// In Python: list2 = list1 would be a shallow copy (same elements)</span>
    <span class="comment">// In Java: ArrayList assignment copies the reference only</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Comparison Table: Assignment Behavior</h4>
                    <table>
                        <tr><th>Language</th><th><code>b = a</code> for Objects</th><th><code>b = a</code> for Primitives</th></tr>
                        <tr><td><strong>Java</strong></td><td>Copies reference (same object)</td><td>Copies value</td></tr>
                        <tr><td><strong>Python</strong></td><td>Copies reference (same object)</td><td>Immutable, so effectively copy</td></tr>
                        <tr><td><strong>C#</strong></td><td>Classes: reference; Structs: value</td><td>Copies value</td></tr>
                        <tr><td><strong>JavaScript</strong></td><td>Copies reference (same object)</td><td>Copies value</td></tr>
                        <tr><td><strong>C++</strong></td><td>Copies entire object (value semantics)</td><td>Copies value</td></tr>
                    </table>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Performance Trap:</strong> Value semantics means <code>void process(std::vector&lt;int&gt; data)</code> copies the ENTIRE vector on each call! Use <code>const&amp;</code> for read-only: <code>void process(const std::vector&lt;int&gt;&amp; data)</code></div>
                    </div>

                    <h4>When to Use Each in C++</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üìã Value (Copy)</h5>
                            <p>Small objects, when you need independence, local modifications. <code>Widget w = other;</code></p>
                        </div>
                        <div class="topic-card">
                            <h5>üîó Reference (<code>&amp;</code>)</h5>
                            <p>Avoid copying, modify original, function parameters. <code>Widget&amp; ref = w;</code></p>
                        </div>
                        <div class="topic-card">
                            <h5>üìç Pointer (<code>*</code>)</h5>
                            <p>Optional (nullable), reseatable, arrays, polymorphism. <code>Widget* ptr = &amp;w;</code></p>
                        </div>
                        <div class="topic-card">
                            <h5>üöÄ Move (<code>std::move</code>)</h5>
                            <p>Transfer ownership, avoid copy of temporaries. <code>Widget w2 = std::move(w1);</code></p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Compilation Model -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>‚öôÔ∏è Compilation Model: Headers, Source Files, and Linking</span>
                </div>
                <div class="collapsible-content">
                    <h4>Why C++ Has Header Files (And Java/Python Don't Need Them)</h4>
                    <p>C++ uses a <strong>separate compilation model</strong> inherited from C. Each <code>.cpp</code> file is compiled independently, and the compiler needs to know about functions/classes before using them. Headers provide these declarations.</p>

                    <div class="code-header">
                        <span>Compilation Model Comparison</span>
                        <span class="lang-badge">Conceptual</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA (Single Compilation Unit) ============</span>
<span class="comment">// Java compiler sees all .java files at once</span>
<span class="comment">// No need for forward declarations</span>
<span class="comment">// JVM loads classes dynamically at runtime</span>

<span class="comment">// ============ PYTHON (Interpreted) ============</span>
<span class="comment">// No compilation step - interpreter reads modules on import</span>
<span class="comment">// import module  # Module loaded and executed</span>

<span class="comment">// ============ C++ (Separate Compilation) ============</span>
<span class="comment">// Each .cpp compiled separately ‚Üí .o object files</span>
<span class="comment">// Linker combines .o files into executable</span>
<span class="comment">// Headers allow compiler to know about external symbols</span>
</code></pre>

                    <h4>The Header/Source Pattern</h4>
                    <div class="code-header">
                        <span>widget.hpp (Header - Declarations)</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#pragma once</span>  <span class="comment">// Modern include guard (or use #ifndef/#define/#endif)</span>

<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="comment">// Class DECLARATION (interface)</span>
<span class="keyword">class</span> <span class="type">Widget</span> {
<span class="keyword">public</span>:
    <span class="function">Widget</span>(<span class="keyword">const</span> std::string& name);  <span class="comment">// Constructor declaration</span>
    <span class="keyword">void</span> <span class="function">doWork</span>();                    <span class="comment">// Method declaration</span>
    std::string <span class="function">getName</span>() <span class="keyword">const</span>;       <span class="comment">// Const method declaration</span>

<span class="keyword">private</span>:
    std::string name_;  <span class="comment">// Member variables</span>
};
</code></pre>

                    <div class="code-header">
                        <span>widget.cpp (Source - Definitions)</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">"widget.hpp"</span>
<span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Constructor DEFINITION</span>
Widget::<span class="function">Widget</span>(<span class="keyword">const</span> std::string& name) : name_(name) {
    std::cout &lt;&lt; <span class="string">"Widget created: "</span> &lt;&lt; name_ &lt;&lt; std::endl;
}

<span class="comment">// Method DEFINITIONS</span>
<span class="keyword">void</span> Widget::<span class="function">doWork</span>() {
    std::cout &lt;&lt; name_ &lt;&lt; <span class="string">" is working"</span> &lt;&lt; std::endl;
}

std::string Widget::<span class="function">getName</span>() <span class="keyword">const</span> {
    <span class="keyword">return</span> name_;
}
</code></pre>

                    <div class="info">
                        <div><strong>üí° Modern C++20 Modules:</strong> C++20 introduces modules (<code>import module_name;</code>) which work more like Java/Python imports. However, most codebases still use headers, so understanding both is essential.</div>
                    </div>

                    <h4>Common Header Pitfalls for Newcomers</h4>
                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Multiple Definition Errors:</strong><br>
                        ‚Ä¢ Don't define functions in headers (only declare) - or use <code>inline</code><br>
                        ‚Ä¢ Don't define non-const global variables in headers<br>
                        ‚Ä¢ Always use include guards (<code>#pragma once</code> or <code>#ifndef</code>)</div>
                    </div>
                </div>
            </div>

            <!-- Quick Reference Cheat Sheet -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìã Quick Translation Cheat Sheet</span>
                </div>
                <div class="collapsible-content">
                    <h4>Common Operations: Java/Python ‚Üí C++</h4>
                    <table>
                        <tr><th>Concept</th><th>Java</th><th>Python</th><th>C++</th></tr>
                        <tr>
                            <td>Create object</td>
                            <td><code>Widget w = new Widget();</code></td>
                            <td><code>w = Widget()</code></td>
                            <td><code>Widget w;</code> (stack) or <code>auto w = make_unique&lt;Widget&gt;();</code> (heap)</td>
                        </tr>
                        <tr>
                            <td>Null/None check</td>
                            <td><code>if (w != null)</code></td>
                            <td><code>if w is not None:</code></td>
                            <td><code>if (ptr != nullptr)</code> (pointers only)</td>
                        </tr>
                        <tr>
                            <td>String</td>
                            <td><code>String s = "hello";</code></td>
                            <td><code>s = "hello"</code></td>
                            <td><code>std::string s = "hello";</code></td>
                        </tr>
                        <tr>
                            <td>List/Vector</td>
                            <td><code>ArrayList&lt;Integer&gt;</code></td>
                            <td><code>list</code></td>
                            <td><code>std::vector&lt;int&gt;</code></td>
                        </tr>
                        <tr>
                            <td>Dictionary/Map</td>
                            <td><code>HashMap&lt;K, V&gt;</code></td>
                            <td><code>dict</code></td>
                            <td><code>std::unordered_map&lt;K, V&gt;</code></td>
                        </tr>
                        <tr>
                            <td>For-each loop</td>
                            <td><code>for (int x : list)</code></td>
                            <td><code>for x in list:</code></td>
                            <td><code>for (int x : vec)</code> or <code>for (const auto& x : vec)</code></td>
                        </tr>
                        <tr>
                            <td>Lambda</td>
                            <td><code>(x) -> x * 2</code></td>
                            <td><code>lambda x: x * 2</code></td>
                            <td><code>[](int x) { return x * 2; }</code></td>
                        </tr>
                        <tr>
                            <td>Interface</td>
                            <td><code>interface IWidget</code></td>
                            <td><code>class IWidget(ABC):</code></td>
                            <td><code>class IWidget { virtual void method() = 0; };</code></td>
                        </tr>
                        <tr>
                            <td>Inheritance</td>
                            <td><code>class B extends A</code></td>
                            <td><code>class B(A):</code></td>
                            <td><code>class B : public A</code></td>
                        </tr>
                        <tr>
                            <td>Print</td>
                            <td><code>System.out.println(x);</code></td>
                            <td><code>print(x)</code></td>
                            <td><code>std::cout &lt;&lt; x &lt;&lt; std::endl;</code></td>
                        </tr>
                    </table>

                    <h4>Mental Model Shifts</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>From Java</h5>
                            <ul>
                                <li>No garbage collector - use RAII/smart pointers</li>
                                <li>No <code>finally</code> - destructors replace it</li>
                                <li>Templates ‚â† Generics (compile-time vs runtime)</li>
                                <li><code>const</code> is powerful and everywhere</li>
                            </ul>
                        </div>
                        <div class="topic-card">
                            <h5>From Python</h5>
                            <ul>
                                <li>Static typing - declare types explicitly</li>
                                <li>Compiled - no interpreter, faster but build step</li>
                                <li>No GIL - true multithreading</li>
                                <li>Semicolons, braces, explicit types</li>
                            </ul>
                        </div>
                        <div class="topic-card">
                            <h5>From C#</h5>
                            <ul>
                                <li>No <code>struct</code> vs <code>class</code> heap/stack difference</li>
                                <li>References work differently</li>
                                <li>No <code>using</code> - RAII handles it</li>
                                <li>Templates more powerful than generics</li>
                            </ul>
                        </div>
                        <div class="topic-card">
                            <h5>From JavaScript</h5>
                            <ul>
                                <li>Strong static typing</li>
                                <li>No prototype inheritance</li>
                                <li>No runtime, no event loop by default</li>
                                <li>Manual memory management</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ==================== BEGINNER SECTION ==================== -->
        <section id="beginner">
            <h2>üìó Beginner Level - C++ Fundamentals <span class="badge badge-beginner">Beginner</span></h2>

            <div class="tip">
                <div>Start here if you're new to C++. Master these fundamentals before moving to intermediate topics. Each concept builds upon the previous one.</div>
            </div>

            <!-- Introduction to C++ -->
            <div class="collapsible active">
                <div class="collapsible-header">
                    <span>üöÄ Introduction to C++</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Basic computer literacy and familiarity with any text editor<br>
                            <strong>üéØ Learning Objectives:</strong> Understand what C++ is, set up your environment, and write your first program<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 1-2 hours<br>
                            <strong>üîó Connects To:</strong> Variables, Functions, Basic I/O
                        </div>
                    </div>

                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b1"><label for="b1">Understanding C++ and its history</label></li>
                        <li><input type="checkbox" id="b2"><label for="b2">Setting up development environment</label></li>
                        <li><input type="checkbox" id="b3"><label for="b3">Your first C++ program</label></li>
                    </ul>

                    <h4>What is C++?</h4>
                    <p>C++ is a powerful, high-performance programming language created by <strong>Bjarne Stroustrup</strong> at Bell Labs in 1979 as an extension of C. Originally called "C with Classes," it was renamed C++ in 1983 (the ++ being the increment operator in C, symbolizing an enhanced version).</p>

                    <h4>Why Learn C++?</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üöÄ Performance</h5>
                            <p>C++ compiles to native machine code, offering unparalleled speed. It's used in game engines (Unreal Engine), browsers (Chrome, Firefox), and operating systems.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üîß Control</h5>
                            <p>Direct memory manipulation, hardware access, and fine-grained resource control make it ideal for system programming and embedded systems.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üìö Paradigms</h5>
                            <p>Supports procedural, object-oriented, generic, and functional programming styles - giving you flexibility in how you design solutions.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üíº Industry Demand</h5>
                            <p>Essential for game development, financial systems, embedded devices, robotics, and high-frequency trading where performance is critical.</p>
                        </div>
                    </div>

                    <h4>C++ Evolution Timeline</h4>
                    <table>
                        <tr><th>Version</th><th>Year</th><th>Key Features</th></tr>
                        <tr><td>C++98</td><td>1998</td><td>First standardized version, STL, templates</td></tr>
                        <tr><td>C++03</td><td>2003</td><td>Bug fixes to C++98</td></tr>
                        <tr><td>C++11</td><td>2011</td><td>auto, lambdas, smart pointers, move semantics, threads</td></tr>
                        <tr><td>C++14</td><td>2014</td><td>Generic lambdas, relaxed constexpr</td></tr>
                        <tr><td>C++17</td><td>2017</td><td>std::optional, structured bindings, if constexpr</td></tr>
                        <tr><td>C++20</td><td>2020</td><td>Concepts, ranges, coroutines, modules</td></tr>
                        <tr><td>C++23</td><td>2023</td><td>std::expected, more constexpr, improved ranges</td></tr>
                    </table>

                    <h4>Setting Up Your Development Environment</h4>
                    <div class="info">
                        <div>
                            <strong>Recommended Setup:</strong><br>
                            ‚Ä¢ <strong>Windows:</strong> Visual Studio 2022 (Community Edition is free) or MinGW-w64 with VS Code<br>
                            ‚Ä¢ <strong>macOS:</strong> Xcode Command Line Tools (<code>xcode-select --install</code>) or Homebrew GCC<br>
                            ‚Ä¢ <strong>Linux:</strong> GCC (<code>sudo apt install g++</code>) or Clang<br>
                            ‚Ä¢ <strong>Online:</strong> <a href="https://godbolt.org" target="_blank">Compiler Explorer</a>, <a href="https://www.onlinegdb.com" target="_blank">OnlineGDB</a>
                        </div>
                    </div>

                    <h4>Your First C++ Program - Explained Line by Line</h4>
                    <div class="code-header">
                        <span>hello_world.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// Line 1: Include the iostream library for input/output operations</span>
<span class="comment">// This is a preprocessor directive - it copies the contents of iostream into your code</span>
<span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Line 2: The main function - every C++ program must have exactly one main()</span>
<span class="comment">// This is where program execution begins</span>
<span class="comment">// 'int' means this function returns an integer value</span>
<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Line 3: Output text to the console</span>
    <span class="comment">// std:: is a namespace prefix (standard library)</span>
    <span class="comment">// cout is the character output stream (console output)</span>
    <span class="comment">// &lt;&lt; is the insertion operator - "sends" data to cout</span>
    <span class="comment">// endl creates a new line and flushes the buffer</span>
    std::cout <span class="operator">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="operator">&lt;&lt;</span> std::endl;

    <span class="comment">// Line 4: Return 0 to indicate successful execution</span>
    <span class="comment">// Non-zero values typically indicate errors</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Compilation Process</h4>
                    <div class="info">
                        <div>
                            <strong>Step-by-step compilation:</strong><br>
                            <code>g++ -o hello hello_world.cpp</code> - Compile the source file<br>
                            <code>./hello</code> (Linux/Mac) or <code>hello.exe</code> (Windows) - Run the executable<br><br>
                            <strong>What happens during compilation:</strong><br>
                            1. <strong>Preprocessing:</strong> Handles #include, #define directives<br>
                            2. <strong>Compilation:</strong> Converts C++ to assembly code<br>
                            3. <strong>Assembly:</strong> Converts assembly to object code (.o files)<br>
                            4. <strong>Linking:</strong> Combines object files into final executable
                        </div>
                    </div>

                    <h4>Alternative: Using Namespaces</h4>
                    <div class="code-header">
                        <span>hello_with_namespace.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Using directive - allows us to omit 'std::' prefix</span>
<span class="comment">// Note: In larger projects, this can cause naming conflicts</span>
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">main</span>() {
    cout <span class="operator">&lt;&lt;</span> <span class="string">"Hello without std:: prefix!"</span> <span class="operator">&lt;&lt;</span> endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Best Practice:</strong> Avoid <code>using namespace std;</code> in header files or large projects. It can cause naming conflicts. Instead, use <code>std::</code> prefix or selective <code>using std::cout;</code> statements.</div>
                    </div>

                    <h4>Common Beginner Mistakes</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>‚ùå Missing Semicolons</h5>
                            <p>Every statement in C++ must end with a semicolon. The compiler error will often point to the <em>next</em> line.</p>
                        </div>
                        <div class="topic-card">
                            <h5>‚ùå Case Sensitivity</h5>
                            <p><code>Main</code> is not the same as <code>main</code>. C++ is case-sensitive throughout.</p>
                        </div>
                        <div class="topic-card">
                            <h5>‚ùå Wrong Quotes</h5>
                            <p>Use double quotes for strings (<code>"text"</code>) and single quotes for single characters (<code>'a'</code>).</p>
                        </div>
                        <div class="topic-card">
                            <h5>‚ùå Missing #include</h5>
                            <p>Forgetting to include necessary headers will cause "undefined" errors for standard library features.</p>
                        </div>
                    </div>

                    <div class="video-section">
                        <h4>üì∫ Recommended Videos</h4>
                        <div class="video-grid">
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>C++ Tutorial for Beginners - Full Course</h5>
                                    <p class="channel">freeCodeCamp.org</p>
                                    <a href="https://www.youtube.com/watch?v=vLnPwxZdW4Y" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>Welcome to C++ (The Cherno)</h5>
                                    <p class="channel">The Cherno</p>
                                    <a href="https://www.youtube.com/watch?v=18c3MTX0PK0" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Variables and Data Types -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üì¶ Variables and Data Types</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Introduction to C++, basic program structure<br>
                            <strong>üéØ Learning Objectives:</strong> Master all C++ data types, understand memory implications, and use type-safe practices<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 2-3 hours<br>
                            <strong>üîó Connects To:</strong> Operators, Functions, Memory Management
                        </div>
                    </div>

                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b4"><label for="b4">Primitive data types (int, float, double, char, bool)</label></li>
                        <li><input type="checkbox" id="b5"><label for="b5">Variable declaration and initialization</label></li>
                        <li><input type="checkbox" id="b6"><label for="b6">Constants and literals</label></li>
                        <li><input type="checkbox" id="b7"><label for="b7">Type modifiers (signed, unsigned, short, long)</label></li>
                        <li><input type="checkbox" id="b8"><label for="b8">Type casting and conversion</label></li>
                    </ul>

                    <h4>What Are Variables?</h4>
                    <p>A <strong>variable</strong> is a named storage location in memory that holds a value. Think of it as a labeled box where you can store and retrieve data. Every variable in C++ has:</p>
                    <ul>
                        <li><strong>Name (identifier):</strong> How you refer to the variable in code</li>
                        <li><strong>Type:</strong> What kind of data it can hold (determines memory size)</li>
                        <li><strong>Value:</strong> The actual data stored</li>
                        <li><strong>Memory address:</strong> Where it's located in RAM</li>
                    </ul>

                    <h4>Fundamental Data Types</h4>
                    <table>
                        <tr><th>Type</th><th>Size (bytes)</th><th>Range</th><th>Use Case</th></tr>
                        <tr><td><code>bool</code></td><td>1</td><td>true/false</td><td>Flags, conditions, states</td></tr>
                        <tr><td><code>char</code></td><td>1</td><td>-128 to 127 or 0-255</td><td>Single characters, small integers</td></tr>
                        <tr><td><code>short</code></td><td>2</td><td>-32,768 to 32,767</td><td>Small numbers, memory-constrained systems</td></tr>
                        <tr><td><code>int</code></td><td>4</td><td>~¬±2.1 billion</td><td>Most integer operations (default choice)</td></tr>
                        <tr><td><code>long</code></td><td>4 or 8</td><td>Platform-dependent</td><td>Larger integers (platform-specific)</td></tr>
                        <tr><td><code>long long</code></td><td>8</td><td>~¬±9.2 quintillion</td><td>Very large numbers, file sizes</td></tr>
                        <tr><td><code>float</code></td><td>4</td><td>~¬±3.4e38 (7 digits)</td><td>Graphics, when memory matters</td></tr>
                        <tr><td><code>double</code></td><td>8</td><td>~¬±1.7e308 (15 digits)</td><td>Scientific calculations (default for decimals)</td></tr>
                    </table>

                    <h4>Variable Declaration Styles</h4>
                    <div class="code-header">
                        <span>variable_declaration.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ DECLARATION STYLES ============</span>

    <span class="comment">// 1. Declaration only (uninitialized - DANGEROUS!)</span>
    <span class="keyword">int</span> uninit;  <span class="comment">// Contains garbage value - avoid this!</span>

    <span class="comment">// 2. Declaration with initialization (copy initialization)</span>
    <span class="keyword">int</span> age = <span class="number">25</span>;

    <span class="comment">// 3. Direct initialization (parentheses)</span>
    <span class="keyword">int</span> count(<span class="number">100</span>);

    <span class="comment">// 4. Uniform/brace initialization (C++11) - RECOMMENDED!</span>
    <span class="keyword">int</span> score{<span class="number">95</span>};          <span class="comment">// Prevents narrowing conversions</span>
    <span class="keyword">int</span> zero{};            <span class="comment">// Zero-initialized</span>
    <span class="comment">// int error{3.14};     // ERROR! Would lose data (narrowing)</span>

    <span class="comment">// 5. Auto type deduction (C++11) - let compiler figure out type</span>
    <span class="keyword">auto</span> pi = <span class="number">3.14159</span>;      <span class="comment">// Deduced as double</span>
    <span class="keyword">auto</span> letter = <span class="string">'A'</span>;     <span class="comment">// Deduced as char</span>
    <span class="keyword">auto</span> name = <span class="string">"Alice"</span>;   <span class="comment">// Deduced as const char*</span>

    <span class="comment">// ============ CONSTANTS ============</span>

    <span class="comment">// const - runtime constant (value set at runtime, but cannot change)</span>
    <span class="keyword">const</span> <span class="keyword">double</span> TAX_RATE = <span class="number">0.08</span>;
    <span class="comment">// TAX_RATE = 0.10;  // ERROR! Cannot modify const</span>

    <span class="comment">// constexpr - compile-time constant (must be computable at compile time)</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_USERS = <span class="number">1000</span>;
    <span class="keyword">constexpr</span> <span class="keyword">double</span> PI = <span class="number">3.14159265359</span>;

    <span class="comment">// ============ TYPE MODIFIERS ============</span>

    <span class="keyword">signed</span> <span class="keyword">int</span> temperature = -<span class="number">10</span>;    <span class="comment">// Can be negative (default)</span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span> fileSize = <span class="number">4000000</span>; <span class="comment">// Only positive (doubles positive range)</span>
    <span class="keyword">short</span> <span class="keyword">int</span> smallNum = <span class="number">100</span>;       <span class="comment">// 2 bytes</span>
    <span class="keyword">long</span> <span class="keyword">int</span> bigNum = <span class="number">1000000L</span>;     <span class="comment">// At least 4 bytes</span>
    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge = <span class="number">9223372036854775807LL</span>;  <span class="comment">// 8 bytes</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Type Casting - Converting Between Types</h4>
                    <div class="code-header">
                        <span>type_casting.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ IMPLICIT CONVERSION (automatic) ============</span>
    <span class="keyword">int</span> intVal = <span class="number">10</span>;
    <span class="keyword">double</span> doubleVal = intVal;  <span class="comment">// int ‚Üí double (safe, no data loss)</span>

    <span class="keyword">double</span> pi = <span class="number">3.14159</span>;
    <span class="keyword">int</span> truncated = pi;  <span class="comment">// double ‚Üí int (DANGEROUS! Loses .14159)</span>

    <span class="comment">// ============ EXPLICIT CASTING (you control it) ============</span>

    <span class="comment">// C-style cast (avoid in modern C++)</span>
    <span class="keyword">int</span> a = (<span class="keyword">int</span>)<span class="number">3.14</span>;  <span class="comment">// Works but not type-safe</span>

    <span class="comment">// static_cast - compile-time cast (RECOMMENDED for most cases)</span>
    <span class="keyword">double</span> price = <span class="number">19.99</span>;
    <span class="keyword">int</span> dollars = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(price);  <span class="comment">// 19</span>

    <span class="comment">// Integer division fix</span>
    <span class="keyword">int</span> x = <span class="number">7</span>, y = <span class="number">2</span>;
    <span class="keyword">double</span> result1 = x / y;  <span class="comment">// 3.0 (integer division first!)</span>
    <span class="keyword">double</span> result2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;  <span class="comment">// 3.5 (correct!)</span>

    std::cout &lt;&lt; <span class="string">"7/2 wrong: "</span> &lt;&lt; result1 &lt;&lt; std::endl;   <span class="comment">// 3</span>
    std::cout &lt;&lt; <span class="string">"7/2 right: "</span> &lt;&lt; result2 &lt;&lt; std::endl;  <span class="comment">// 3.5</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Real-World Application: User Profile System</h4>
                    <div class="code-header">
                        <span>user_profile_example.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Real-world example: User profile data</span>

    <span class="comment">// User identification</span>
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> userId = <span class="number">1234567890123456</span>;  <span class="comment">// Large IDs need long long</span>
    std::string username = <span class="string">"john_doe"</span>;          <span class="comment">// std::string for text</span>

    <span class="comment">// Personal info</span>
    <span class="keyword">int</span> age = <span class="number">28</span>;                   <span class="comment">// Regular int is fine for age</span>
    <span class="keyword">char</span> gender = <span class="string">'M'</span>;             <span class="comment">// Single character</span>
    <span class="keyword">double</span> height = <span class="number">1.75</span>;          <span class="comment">// Meters - needs precision</span>
    <span class="keyword">float</span> weight = <span class="number">70.5f</span>;          <span class="comment">// Kilograms - float is sufficient</span>

    <span class="comment">// Account status</span>
    <span class="keyword">bool</span> isVerified = <span class="keyword">true</span>;        <span class="comment">// Boolean for flags</span>
    <span class="keyword">bool</span> isPremium = <span class="keyword">false</span>;

    <span class="comment">// Financial data (always use appropriate precision!)</span>
    <span class="keyword">double</span> accountBalance = <span class="number">1234.56</span>;  <span class="comment">// Money needs double precision</span>

    <span class="comment">// Constants for the application</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> MIN_AGE = <span class="number">13</span>;
    <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_AGE = <span class="number">120</span>;
    <span class="keyword">const</span> <span class="keyword">double</span> PREMIUM_DISCOUNT = <span class="number">0.20</span>;

    <span class="comment">// Calculate BMI</span>
    <span class="keyword">double</span> bmi = weight / (height * height);

    std::cout &lt;&lt; <span class="string">"User: "</span> &lt;&lt; username &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"BMI: "</span> &lt;&lt; bmi &lt;&lt; std::endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Common Pitfalls:</strong><br>
                        ‚Ä¢ <strong>Integer overflow:</strong> <code>int x = 2147483647; x++;</code> wraps to negative!<br>
                        ‚Ä¢ <strong>Uninitialized variables:</strong> Contain garbage - always initialize!<br>
                        ‚Ä¢ <strong>Integer division:</strong> <code>5/2 = 2</code>, not 2.5. Cast to double first!<br>
                        ‚Ä¢ <strong>Floating-point comparison:</strong> Never use <code>==</code> with floats due to precision issues.</div>
                    </div>

                    <div class="info">
                        <div><strong>üí° Best Practices:</strong><br>
                        ‚Ä¢ Use <code>int</code> for most integers, <code>double</code> for decimals<br>
                        ‚Ä¢ Prefer <code>unsigned</code> only for bit manipulation or when values are truly non-negative<br>
                        ‚Ä¢ Use brace initialization <code>{}</code> to catch narrowing conversions<br>
                        ‚Ä¢ Use <code>constexpr</code> for compile-time constants, <code>const</code> for runtime constants</div>
                    </div>
                </div>
            </div>

            <!-- Operators -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>‚ö° Operators</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b9"><label for="b9">Arithmetic operators (+, -, *, /, %)</label></li>
                        <li><input type="checkbox" id="b10"><label for="b10">Relational operators (==, !=, <, >, <=, >=)</label></li>
                        <li><input type="checkbox" id="b11"><label for="b11">Logical operators (&&, ||, !)</label></li>
                        <li><input type="checkbox" id="b12"><label for="b12">Bitwise operators (&, |, ^, ~, <<, >>)</label></li>
                        <li><input type="checkbox" id="b13"><label for="b13">Assignment and compound operators</label></li>
                        <li><input type="checkbox" id="b14"><label for="b14">Operator precedence</label></li>
                    </ul>

                    <div class="code-header">
                        <span>operators.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Arithmetic operators</span>
    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">3</span>;
    std::cout &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; (a + b) &lt;&lt; std::endl;  <span class="comment">// 13</span>
    std::cout &lt;&lt; <span class="string">"a / b = "</span> &lt;&lt; (a / b) &lt;&lt; std::endl;  <span class="comment">// 3 (integer division)</span>
    std::cout &lt;&lt; <span class="string">"a % b = "</span> &lt;&lt; (a % b) &lt;&lt; std::endl;  <span class="comment">// 1 (remainder)</span>

    <span class="comment">// Increment/Decrement</span>
    <span class="keyword">int</span> x = <span class="number">5</span>;
    std::cout &lt;&lt; <span class="string">"++x = "</span> &lt;&lt; ++x &lt;&lt; std::endl;  <span class="comment">// 6 (pre-increment)</span>
    std::cout &lt;&lt; <span class="string">"x++ = "</span> &lt;&lt; x++ &lt;&lt; std::endl;  <span class="comment">// 6, then x becomes 7</span>

    <span class="comment">// Relational operators</span>
    std::cout &lt;&lt; <span class="string">"10 > 5: "</span> &lt;&lt; (<span class="number">10</span> > <span class="number">5</span>) &lt;&lt; std::endl;   <span class="comment">// 1 (true)</span>
    std::cout &lt;&lt; <span class="string">"10 == 10: "</span> &lt;&lt; (<span class="number">10</span> == <span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 1 (true)</span>

    <span class="comment">// Logical operators</span>
    <span class="keyword">bool</span> p = <span class="keyword">true</span>, q = <span class="keyword">false</span>;
    std::cout &lt;&lt; <span class="string">"p && q: "</span> &lt;&lt; (p && q) &lt;&lt; std::endl;  <span class="comment">// 0 (false)</span>
    std::cout &lt;&lt; <span class="string">"p || q: "</span> &lt;&lt; (p || q) &lt;&lt; std::endl;  <span class="comment">// 1 (true)</span>
    std::cout &lt;&lt; <span class="string">"!p: "</span> &lt;&lt; !p &lt;&lt; std::endl;            <span class="comment">// 0 (false)</span>

    <span class="comment">// Bitwise operators</span>
    <span class="keyword">int</span> m = <span class="number">5</span>, n = <span class="number">3</span>;  <span class="comment">// 5 = 101, 3 = 011 in binary</span>
    std::cout &lt;&lt; <span class="string">"5 & 3 = "</span> &lt;&lt; (m & n) &lt;&lt; std::endl;   <span class="comment">// 1 (001)</span>
    std::cout &lt;&lt; <span class="string">"5 | 3 = "</span> &lt;&lt; (m | n) &lt;&lt; std::endl;   <span class="comment">// 7 (111)</span>
    std::cout &lt;&lt; <span class="string">"5 ^ 3 = "</span> &lt;&lt; (m ^ n) &lt;&lt; std::endl;   <span class="comment">// 6 (110)</span>
    std::cout &lt;&lt; <span class="string">"5 << 1 = "</span> &lt;&lt; (m &lt;&lt; <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// 10 (left shift)</span>

    <span class="comment">// Ternary operator</span>
    <span class="keyword">int</span> age = <span class="number">20</span>;
    std::string status = (age >= <span class="number">18</span>) ? <span class="string">"Adult"</span> : <span class="string">"Minor"</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="note">
                        <div><strong>Operator Precedence:</strong> Unary > Arithmetic > Relational > Logical > Assignment. When in doubt, use parentheses!</div>
                    </div>
                </div>
            </div>

            <!-- Control Structures -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üîÄ Control Structures</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b15"><label for="b15">if, else if, else statements</label></li>
                        <li><input type="checkbox" id="b16"><label for="b16">switch-case statements</label></li>
                        <li><input type="checkbox" id="b17"><label for="b17">for loops</label></li>
                        <li><input type="checkbox" id="b18"><label for="b18">while and do-while loops</label></li>
                        <li><input type="checkbox" id="b19"><label for="b19">break, continue, and goto</label></li>
                        <li><input type="checkbox" id="b20"><label for="b20">Range-based for loops (C++11)</label></li>
                    </ul>

                    <div class="code-header">
                        <span>control_structures.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// If-else statement</span>
    <span class="keyword">int</span> score = <span class="number">85</span>;
    <span class="keyword">if</span> (score >= <span class="number">90</span>) {
        std::cout &lt;&lt; <span class="string">"Grade: A"</span> &lt;&lt; std::endl;
    } <span class="keyword">else if</span> (score >= <span class="number">80</span>) {
        std::cout &lt;&lt; <span class="string">"Grade: B"</span> &lt;&lt; std::endl;
    } <span class="keyword">else if</span> (score >= <span class="number">70</span>) {
        std::cout &lt;&lt; <span class="string">"Grade: C"</span> &lt;&lt; std::endl;
    } <span class="keyword">else</span> {
        std::cout &lt;&lt; <span class="string">"Grade: F"</span> &lt;&lt; std::endl;
    }

    <span class="comment">// Switch statement</span>
    <span class="keyword">char</span> operation = <span class="string">'+'</span>;
    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>, result;
    <span class="keyword">switch</span> (operation) {
        <span class="keyword">case</span> <span class="string">'+'</span>: result = a + b; <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'-'</span>: result = a - b; <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'*'</span>: result = a * b; <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'/'</span>: result = a / b; <span class="keyword">break</span>;
        <span class="keyword">default</span>: result = <span class="number">0</span>;
    }

    <span class="comment">// For loop</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
        std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;
    }
    std::cout &lt;&lt; std::endl;

    <span class="comment">// While loop</span>
    <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="keyword">while</span> (count &lt; <span class="number">3</span>) {
        std::cout &lt;&lt; <span class="string">"Count: "</span> &lt;&lt; count++ &lt;&lt; std::endl;
    }

    <span class="comment">// Do-while loop (executes at least once)</span>
    <span class="keyword">int</span> num;
    <span class="keyword">do</span> {
        std::cout &lt;&lt; <span class="string">"Enter a positive number: "</span>;
        std::cin >> num;
    } <span class="keyword">while</span> (num &lt;= <span class="number">0</span>);

    <span class="comment">// Range-based for loop (C++11)</span>
    std::vector&lt;<span class="keyword">int</span>&gt; numbers = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    <span class="keyword">for</span> (<span class="keyword">const auto</span>& n : numbers) {
        std::cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Functions -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üîß Functions</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Variables, data types, control structures<br>
                            <strong>üéØ Learning Objectives:</strong> Write reusable code blocks, understand parameter passing, master function design<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 3-4 hours<br>
                            <strong>üîó Connects To:</strong> Classes, Templates, Lambdas, Recursion algorithms
                        </div>
                    </div>

                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b21"><label for="b21">Function declaration and definition</label></li>
                        <li><input type="checkbox" id="b22"><label for="b22">Parameters and return values</label></li>
                        <li><input type="checkbox" id="b23"><label for="b23">Pass by value vs pass by reference</label></li>
                        <li><input type="checkbox" id="b24"><label for="b24">Default parameters</label></li>
                        <li><input type="checkbox" id="b25"><label for="b25">Function overloading</label></li>
                        <li><input type="checkbox" id="b26"><label for="b26">Inline functions</label></li>
                        <li><input type="checkbox" id="b27"><label for="b27">Recursion</label></li>
                    </ul>

                    <h4>What Are Functions?</h4>
                    <p>Functions are <strong>reusable blocks of code</strong> that perform specific tasks. They help you:</p>
                    <ul>
                        <li><strong>Organize code:</strong> Break complex problems into smaller, manageable pieces</li>
                        <li><strong>Avoid repetition:</strong> Write once, use many times (DRY principle)</li>
                        <li><strong>Improve readability:</strong> Give meaningful names to operations</li>
                        <li><strong>Enable testing:</strong> Test individual components in isolation</li>
                    </ul>

                    <h4>Function Anatomy</h4>
                    <div class="code-header">
                        <span>function_anatomy.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// ============ FUNCTION DECLARATION (Prototype) ============</span>
<span class="comment">// Tells compiler the function exists - enables calling before definition</span>
<span class="comment">// Typically placed in header files (.h/.hpp)</span>
<span class="keyword">int</span> <span class="function">calculateSum</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b);  <span class="comment">// Return type, name, parameters</span>

<span class="comment">// ============ FUNCTION DEFINITION ============</span>
<span class="comment">// The actual implementation with code body</span>
<span class="keyword">int</span> <span class="function">calculateSum</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {  <span class="comment">// &lt;-- Function header</span>
    <span class="keyword">int</span> result = a + b;              <span class="comment">// &lt;-- Function body</span>
    <span class="keyword">return</span> result;                   <span class="comment">// &lt;-- Return statement</span>
}

<span class="comment">// ============ VOID FUNCTIONS (no return value) ============</span>
<span class="keyword">void</span> <span class="function">printMessage</span>(<span class="keyword">const</span> std::string& msg) {
    std::cout &lt;&lt; msg &lt;&lt; std::endl;
    <span class="comment">// No return statement needed (or use 'return;' to exit early)</span>
}
</code></pre>

                    <h4>Parameter Passing - The Critical Concept</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üìã Pass by Value</h5>
                            <p>Creates a <strong>copy</strong> of the argument. Changes inside function don't affect original. Safe but can be slow for large objects.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üîó Pass by Reference</h5>
                            <p>Passes the <strong>actual variable</strong>. Changes affect the original. Efficient for large objects. Use <code>const&</code> for read-only.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üìç Pass by Pointer</h5>
                            <p>Passes memory address. Can be null (optional parameter). Use when you need to reseat the pointer itself.</p>
                        </div>
                    </div>

                    <div class="code-header">
                        <span>parameter_passing.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="comment">// ============ PASS BY VALUE ============</span>
<span class="comment">// Creates a copy - original unchanged</span>
<span class="keyword">void</span> <span class="function">doubleValue</span>(<span class="keyword">int</span> x) {
    x = x * <span class="number">2</span>;  <span class="comment">// Only modifies the local copy</span>
    std::cout &lt;&lt; <span class="string">"Inside function: "</span> &lt;&lt; x &lt;&lt; std::endl;
}

<span class="comment">// ============ PASS BY REFERENCE ============</span>
<span class="comment">// Works with the actual variable - original IS modified</span>
<span class="keyword">void</span> <span class="function">doubleByReference</span>(<span class="keyword">int</span>& x) {  <span class="comment">// Note the &amp;</span>
    x = x * <span class="number">2</span>;  <span class="comment">// Modifies the original variable</span>
}

<span class="comment">// ============ CONST REFERENCE ============</span>
<span class="comment">// Efficient AND safe - can't modify, no copy made</span>
<span class="keyword">void</span> <span class="function">printVector</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& vec) {
    <span class="comment">// vec.push_back(5);  // ERROR! Can't modify const</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> n : vec) {
        std::cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;
    }
}

<span class="comment">// ============ MULTIPLE RETURN VALUES (using reference parameters) ============</span>
<span class="keyword">void</span> <span class="function">getMinMax</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& vec, <span class="keyword">int</span>& minVal, <span class="keyword">int</span>& maxVal) {
    minVal = vec[<span class="number">0</span>];
    maxVal = vec[<span class="number">0</span>];
    <span class="keyword">for</span> (<span class="keyword">int</span> n : vec) {
        <span class="keyword">if</span> (n &lt; minVal) minVal = n;
        <span class="keyword">if</span> (n > maxVal) maxVal = n;
    }
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> num = <span class="number">10</span>;

    doubleValue(num);
    std::cout &lt;&lt; <span class="string">"After pass by value: "</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// Still 10!</span>

    doubleByReference(num);
    std::cout &lt;&lt; <span class="string">"After pass by reference: "</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// Now 20!</span>

    <span class="comment">// Multiple return values</span>
    std::vector&lt;<span class="keyword">int</span>&gt; data = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>};
    <span class="keyword">int</span> minV, maxV;
    getMinMax(data, minV, maxV);
    std::cout &lt;&lt; <span class="string">"Min: "</span> &lt;&lt; minV &lt;&lt; <span class="string">", Max: "</span> &lt;&lt; maxV &lt;&lt; std::endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Function Overloading - Same Name, Different Parameters</h4>
                    <div class="code-header">
                        <span>overloading.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="comment">// Compiler chooses the right version based on arguments</span>
<span class="comment">// This is COMPILE-TIME polymorphism</span>

<span class="keyword">void</span> <span class="function">print</span>(<span class="keyword">int</span> value) {
    std::cout &lt;&lt; <span class="string">"Integer: "</span> &lt;&lt; value &lt;&lt; std::endl;
}

<span class="keyword">void</span> <span class="function">print</span>(<span class="keyword">double</span> value) {
    std::cout &lt;&lt; <span class="string">"Double: "</span> &lt;&lt; value &lt;&lt; std::endl;
}

<span class="keyword">void</span> <span class="function">print</span>(<span class="keyword">const</span> std::string& value) {
    std::cout &lt;&lt; <span class="string">"String: "</span> &lt;&lt; value &lt;&lt; std::endl;
}

<span class="keyword">void</span> <span class="function">print</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {  <span class="comment">// Different number of parameters</span>
    std::cout &lt;&lt; <span class="string">"Two ints: "</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; std::endl;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    print(<span class="number">42</span>);           <span class="comment">// Calls print(int)</span>
    print(<span class="number">3.14</span>);         <span class="comment">// Calls print(double)</span>
    print(<span class="string">"Hello"</span>);      <span class="comment">// Calls print(string)</span>
    print(<span class="number">10</span>, <span class="number">20</span>);       <span class="comment">// Calls print(int, int)</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Default Parameters and Recursion</h4>
                    <div class="code-header">
                        <span>defaults_and_recursion.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// ============ DEFAULT PARAMETERS ============</span>
<span class="comment">// Must be rightmost parameters - can't have defaults before non-defaults</span>
<span class="keyword">void</span> <span class="function">createUser</span>(
    <span class="keyword">const</span> std::string& name,
    <span class="keyword">int</span> age = <span class="number">18</span>,                    <span class="comment">// Default: 18</span>
    <span class="keyword">const</span> std::string& role = <span class="string">"user"</span>  <span class="comment">// Default: "user"</span>
) {
    std::cout &lt;&lt; name &lt;&lt; <span class="string">", "</span> &lt;&lt; age &lt;&lt; <span class="string">", "</span> &lt;&lt; role &lt;&lt; std::endl;
}

<span class="comment">// ============ RECURSION ============</span>
<span class="comment">// Function that calls itself - must have a BASE CASE to stop!</span>

<span class="comment">// Classic example: Factorial (5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120)</span>
<span class="keyword">int</span> <span class="function">factorial</span>(<span class="keyword">int</span> n) {
    <span class="comment">// Base case - stops the recursion</span>
    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;

    <span class="comment">// Recursive case - calls itself with smaller problem</span>
    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);
}

<span class="comment">// Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, ...</span>
<span class="keyword">int</span> <span class="function">fibonacci</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Base case 1</span>
    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Base case 2</span>
    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);  <span class="comment">// Recursive case</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Default parameters in action</span>
    createUser(<span class="string">"Alice"</span>);                 <span class="comment">// Alice, 18, user</span>
    createUser(<span class="string">"Bob"</span>, <span class="number">25</span>);               <span class="comment">// Bob, 25, user</span>
    createUser(<span class="string">"Charlie"</span>, <span class="number">30</span>, <span class="string">"admin"</span>);  <span class="comment">// Charlie, 30, admin</span>

    <span class="comment">// Recursion examples</span>
    std::cout &lt;&lt; <span class="string">"5! = "</span> &lt;&lt; factorial(<span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 120</span>
    std::cout &lt;&lt; <span class="string">"Fib(10) = "</span> &lt;&lt; fibonacci(<span class="number">10</span>) &lt;&lt; std::endl;  <span class="comment">// 55</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Recursion Pitfalls:</strong><br>
                        ‚Ä¢ <strong>Stack overflow:</strong> Too many recursive calls exhaust stack memory<br>
                        ‚Ä¢ <strong>Missing base case:</strong> Infinite recursion = crash<br>
                        ‚Ä¢ <strong>Performance:</strong> Naive recursion can be slow (use memoization or iteration for efficiency)</div>
                    </div>

                    <div class="info">
                        <div><strong>üí° Best Practices:</strong><br>
                        ‚Ä¢ Use <code>const&</code> for input parameters you won't modify (efficient + safe)<br>
                        ‚Ä¢ Use <code>&</code> for output parameters or when you need to modify<br>
                        ‚Ä¢ Keep functions small and focused (Single Responsibility Principle)<br>
                        ‚Ä¢ Prefer descriptive function names: <code>calculateTax()</code> over <code>calc()</code><br>
                        ‚Ä¢ Document complex functions with comments explaining purpose and parameters</div>
                    </div>
                </div>
            </div>

            <!-- Arrays and Pointers -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìç Arrays and Pointers</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context for Experienced Developers -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Variables, functions, basic memory concepts<br>
                            <strong>üéØ Learning Objectives:</strong> Understand direct memory access, pointer/reference semantics, manual memory management<br>
                            <strong>üîÑ Coming from Other Languages:</strong> This is C++'s most unique feature - direct memory manipulation. Java/Python/JS hide this entirely.<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 4-6 hours (this is THE critical topic for C++ mastery)
                        </div>
                    </div>

                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b28"><label for="b28">One-dimensional arrays</label></li>
                        <li><input type="checkbox" id="b29"><label for="b29">Multi-dimensional arrays</label></li>
                        <li><input type="checkbox" id="b30"><label for="b30">Pointer basics and memory addresses</label></li>
                        <li><input type="checkbox" id="b31"><label for="b31">Pointer arithmetic</label></li>
                        <li><input type="checkbox" id="b32"><label for="b32">Arrays and pointers relationship</label></li>
                        <li><input type="checkbox" id="b33"><label for="b33">Dynamic memory allocation (new/delete)</label></li>
                        <li><input type="checkbox" id="b34"><label for="b34">References vs pointers</label></li>
                    </ul>

                    <h4>üß† Conceptual Foundation: What Are Pointers?</h4>
                    <p>A <strong>pointer</strong> is a variable that stores the memory address of another variable. Unlike Java references or Python object references, C++ pointers give you direct access to memory addresses and allow arithmetic on those addresses.</p>

                    <h4>üîÑ Cross-Language Comparison: Indirection Mechanisms</h4>
                    <table>
                        <tr><th>Language</th><th>Mechanism</th><th>Can be Null?</th><th>Arithmetic?</th><th>Direct Memory Access?</th></tr>
                        <tr><td><strong>C++ Pointer</strong></td><td><code>int* ptr</code></td><td>Yes (<code>nullptr</code>)</td><td>Yes</td><td>Yes (addresses visible)</td></tr>
                        <tr><td><strong>C++ Reference</strong></td><td><code>int&amp; ref</code></td><td>No</td><td>No</td><td>No (abstracted away)</td></tr>
                        <tr><td><strong>Java Reference</strong></td><td><code>Object obj</code></td><td>Yes (<code>null</code>)</td><td>No</td><td>No (JVM manages)</td></tr>
                        <tr><td><strong>Python Reference</strong></td><td><code>obj = ...</code></td><td>Yes (<code>None</code>)</td><td>No</td><td>No (interpreter manages)</td></tr>
                        <tr><td><strong>C# Reference</strong></td><td><code>object obj</code></td><td>Yes (<code>null</code>)</td><td>No*</td><td>No* (unsafe mode only)</td></tr>
                    </table>

                    <div class="info">
                        <div><strong>üí° Key Insight for Java/Python Developers:</strong> What you call "references" in Java/Python are actually more like C++ <code>shared_ptr</code> - they're managed handles to heap objects. C++ <em>references</em> are different: they're compile-time aliases with no runtime overhead, and they cannot be null or reseated.</div>
                    </div>

                    <h4>The Fundamental Operators</h4>
                    <div class="code-header">
                        <span>pointer_fundamentals.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> x = <span class="number">42</span>;

    <span class="comment">// ============ THE TWO KEY OPERATORS ============</span>
    <span class="comment">// &amp; (address-of): Gets the memory address of a variable</span>
    <span class="comment">// * (dereference): Accesses the value at a memory address</span>

    <span class="keyword">int</span>* ptr = &x;   <span class="comment">// ptr now holds the ADDRESS of x (e.g., 0x7ffd5e8c3a4c)</span>

    std::cout &lt;&lt; <span class="string">"x value:     "</span> &lt;&lt; x &lt;&lt; std::endl;      <span class="comment">// 42</span>
    std::cout &lt;&lt; <span class="string">"x address:   "</span> &lt;&lt; &x &lt;&lt; std::endl;     <span class="comment">// 0x7ffd5e8c3a4c</span>
    std::cout &lt;&lt; <span class="string">"ptr value:   "</span> &lt;&lt; ptr &lt;&lt; std::endl;    <span class="comment">// 0x7ffd5e8c3a4c (same!)</span>
    std::cout &lt;&lt; <span class="string">"ptr deref:   "</span> &lt;&lt; *ptr &lt;&lt; std::endl;   <span class="comment">// 42 (value at address)</span>

    <span class="comment">// Modifying through pointer modifies original!</span>
    *ptr = <span class="number">100</span>;
    std::cout &lt;&lt; <span class="string">"x is now:    "</span> &lt;&lt; x &lt;&lt; std::endl;      <span class="comment">// 100</span>

    <span class="comment">// ============ COMPARISON TO JAVA/PYTHON ============</span>
    <span class="comment">// In Java:  Integer x = 42; Integer y = x;  // y points to same Integer object</span>
    <span class="comment">// In Python: x = 42; y = x  // y points to same int object (but ints are immutable)</span>
    <span class="comment">// </span>
    <span class="comment">// In C++, there's no object - just raw memory containing the value 42.</span>
    <span class="comment">// The pointer gives you direct access to that memory location.</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>C++ References - The Safer Alternative</h4>
                    <p><strong>References</strong> are C++'s answer to the question: "What if we want pointer-like behavior without the complexity?" They provide:</p>
                    <ul>
                        <li><strong>Cannot be null:</strong> Must be initialized to a valid object</li>
                        <li><strong>Cannot be reseated:</strong> Always refers to the same object</li>
                        <li><strong>Automatic dereferencing:</strong> Use like a normal variable</li>
                    </ul>

                    <div class="code-header">
                        <span>references_explained.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Pass by reference - modifies original (like Java object parameters)</span>
<span class="keyword">void</span> <span class="function">doubleValue</span>(<span class="keyword">int</span>& num) {
    num *= <span class="number">2</span>;  <span class="comment">// No need for * operator - automatic</span>
}

<span class="comment">// Pass by const reference - read-only, efficient for large objects</span>
<span class="keyword">void</span> <span class="function">printData</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& data) {
    <span class="comment">// data cannot be modified here</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> val : data) std::cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> x = <span class="number">10</span>;
    <span class="keyword">int</span>& ref = x;    <span class="comment">// ref IS x (alias) - not a copy, not a pointer</span>

    ref = <span class="number">20</span>;        <span class="comment">// x is now 20</span>

    doubleValue(x);  <span class="comment">// x is now 40</span>

    <span class="comment">// ============ REFERENCES VS POINTERS ============</span>
    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;

    <span class="keyword">int</span>* ptr = &a;    <span class="comment">// ptr points to a</span>
    ptr = &b;         <span class="comment">// ptr now points to b (reseated)</span>

    <span class="keyword">int</span>& ref2 = a;   <span class="comment">// ref2 IS a</span>
    <span class="comment">// ref2 = &amp;b;      // ERROR! This assigns b's VALUE to a, doesn't reseat</span>
    ref2 = b;        <span class="comment">// This sets a = 2, not rebinding ref2</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Dynamic Memory: new/delete vs Garbage Collection</h4>
                    <div class="code-header">
                        <span>dynamic_memory.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ JAVA EQUIVALENT ============</span>
    <span class="comment">// int[] arr = new int[10];  // Java - GC will clean up</span>

    <span class="comment">// ============ C++ - YOU MUST MANAGE MEMORY ============</span>
    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">// Allocate array on heap</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        arr[i] = i * i;
    }

    <span class="comment">// Without this, MEMORY LEAK!</span>
    <span class="keyword">delete</span>[] arr;  <span class="comment">// [] for arrays, delete for single objects</span>

    <span class="comment">// ============ WHAT HAPPENS WITHOUT DELETE ============</span>
    <span class="comment">// - Memory remains allocated but inaccessible (leak)</span>
    <span class="comment">// - Program memory usage grows over time</span>
    <span class="comment">// - Eventually system runs out of memory</span>
    <span class="comment">// - No GC will save you!</span>

    <span class="comment">// ============ MODERN C++ - USE SMART POINTERS ============</span>
    <span class="comment">// auto arr = std::make_unique&lt;int[]&gt;(10);  // Automatically freed!</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>‚ö†Ô∏è Common Pitfalls for Developers from GC Languages</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üî¥ Dangling Pointer</h5>
                            <p>Using a pointer after <code>delete</code>. In Java, GC prevents this. In C++, it's undefined behavior - may crash, corrupt data, or seem to work.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Memory Leak</h5>
                            <p>Forgetting <code>delete</code>. Every <code>new</code> needs a <code>delete</code>. Use smart pointers to avoid manual management.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Double Delete</h5>
                            <p>Calling <code>delete</code> twice on same memory. Crash or corruption. Set pointer to <code>nullptr</code> after delete.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Array vs Single Delete</h5>
                            <p><code>new[]</code> requires <code>delete[]</code>. Mixing them causes undefined behavior.</p>
                        </div>
                    </div>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Modern C++ Recommendation:</strong> Avoid raw <code>new</code>/<code>delete</code> in modern code. Use <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and containers like <code>std::vector</code>. They provide automatic memory management without GC overhead.</div>
                    </div>

                    <div class="video-section">
                        <h4>Recommended Videos on Pointers</h4>
                        <div class="video-grid">
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>Pointers in C / C++ [Full Course]</h5>
                                    <p class="channel">freeCodeCamp.org</p>
                                    <a href="https://www.youtube.com/watch?v=zuegQmMdy8M" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>Pointers in C++ (The Cherno)</h5>
                                    <p class="channel">The Cherno</p>
                                    <a href="https://www.youtube.com/watch?v=DTxHyVn0ODg" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Basic Classes -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üèóÔ∏è Classes and Objects Basics</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Variables, functions, basic program structure<br>
                            <strong>üéØ Learning Objectives:</strong> Define classes, understand access control, constructors/destructors<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 3-4 hours<br>
                            <strong>üîó Connects To:</strong> Inheritance, Polymorphism, RAII, Smart Pointers<br>
                            <strong>üîÑ Coming from Other Languages:</strong> C++ classes are similar to Java/C# but with key differences in memory and destructors
                        </div>
                    </div>

                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b35"><label for="b35">Class definition and object creation</label></li>
                        <li><input type="checkbox" id="b36"><label for="b36">Access specifiers (public, private, protected)</label></li>
                        <li><input type="checkbox" id="b37"><label for="b37">Member functions and data members</label></li>
                        <li><input type="checkbox" id="b38"><label for="b38">Constructors and destructors</label></li>
                        <li><input type="checkbox" id="b39"><label for="b39">this pointer</label></li>
                        <li><input type="checkbox" id="b40"><label for="b40">Static members</label></li>
                    </ul>

                    <h4>üîÑ C++ Classes vs Java/Python Classes</h4>
                    <table>
                        <tr><th>Aspect</th><th>Java</th><th>Python</th><th>C++</th></tr>
                        <tr><td><strong>Default access</strong></td><td>Package-private</td><td>Public (convention: <code>_private</code>)</td><td><code>private</code> for class, <code>public</code> for struct</td></tr>
                        <tr><td><strong>Object creation</strong></td><td>Always on heap (<code>new</code>)</td><td>Always on heap</td><td>Stack or heap (you choose)</td></tr>
                        <tr><td><strong>Destructor</strong></td><td>None (finalize deprecated)</td><td><code>__del__</code> (unreliable)</td><td>Always called deterministically</td></tr>
                        <tr><td><strong>Multiple inheritance</strong></td><td>No (interfaces only)</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td><strong>Operator overloading</strong></td><td>No</td><td>Yes (<code>__add__</code>, etc.)</td><td>Yes (<code>operator+</code>, etc.)</td></tr>
                        <tr><td><strong>this/self</strong></td><td><code>this</code> (implicit)</td><td><code>self</code> (explicit param)</td><td><code>this</code> (pointer, implicit)</td></tr>
                    </table>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Critical Difference from Java:</strong> In C++, <code>Person p;</code> creates the object <em>directly on the stack</em>. There's no <code>new</code> needed, and the destructor runs automatically when <code>p</code> goes out of scope. This is RAII - one of C++'s most powerful features!</div>
                    </div>

                    <h4>Object Creation: Stack vs Heap</h4>
                    <div class="code-header">
                        <span>object_creation_comparison.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA ALWAYS DOES THIS ============</span>
<span class="comment">// Person p = new Person("Alice", 25);  // Heap allocation, GC cleanup</span>

<span class="comment">// ============ C++ GIVES YOU CHOICES ============</span>

<span class="comment">// 1. STACK ALLOCATION (preferred in C++)</span>
{
    Person p(<span class="string">"Alice"</span>, <span class="number">25</span>);  <span class="comment">// Created on stack - fast!</span>
    p.introduce();
}  <span class="comment">// Destructor called HERE - deterministic, immediate, guaranteed</span>

<span class="comment">// 2. HEAP ALLOCATION (like Java, but manual)</span>
Person* ptr = <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">30</span>);  <span class="comment">// On heap</span>
ptr->introduce();  <span class="comment">// Arrow operator for pointers</span>
<span class="keyword">delete</span> ptr;        <span class="comment">// YOU must free it! No GC!</span>

<span class="comment">// 3. MODERN C++ (best practice)</span>
<span class="keyword">auto</span> smartPtr = std::make_unique&lt;Person&gt;(<span class="string">"Charlie"</span>, <span class="number">35</span>);
smartPtr->introduce();
<span class="comment">// Automatically deleted when smartPtr goes out of scope</span>
</code></pre>

                    <h4>Basic Class Example</h4>
                    <div class="code-header">
                        <span>basic_class.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="keyword">class</span> <span class="type">Person</span> {
<span class="keyword">private</span>:
    std::string name;
    <span class="keyword">int</span> age;
    <span class="keyword">static</span> <span class="keyword">int</span> count;  <span class="comment">// Static member</span>

<span class="keyword">public</span>:
    <span class="comment">// Default constructor</span>
    <span class="function">Person</span>() : name(<span class="string">"Unknown"</span>), age(<span class="number">0</span>) {
        count++;
    }

    <span class="comment">// Parameterized constructor</span>
    <span class="function">Person</span>(<span class="keyword">const</span> std::string& n, <span class="keyword">int</span> a) : name(n), age(a) {
        count++;
    }

    <span class="comment">// Destructor</span>
    <span class="function">~Person</span>() {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">" destroyed"</span> &lt;&lt; std::endl;
        count--;
    }

    <span class="comment">// Getter methods</span>
    std::string <span class="function">getName</span>() <span class="keyword">const</span> { <span class="keyword">return</span> name; }
    <span class="keyword">int</span> <span class="function">getAge</span>() <span class="keyword">const</span> { <span class="keyword">return</span> age; }

    <span class="comment">// Setter methods</span>
    <span class="keyword">void</span> <span class="function">setName</span>(<span class="keyword">const</span> std::string& n) { name = n; }
    <span class="keyword">void</span> <span class="function">setAge</span>(<span class="keyword">int</span> a) {
        <span class="keyword">if</span> (a >= <span class="number">0</span>) age = a;
    }

    <span class="comment">// Member function using 'this'</span>
    <span class="keyword">void</span> <span class="function">introduce</span>() {
        std::cout &lt;&lt; <span class="string">"Hi, I'm "</span> &lt;&lt; <span class="keyword">this</span>->name
                  &lt;&lt; <span class="string">", age "</span> &lt;&lt; <span class="keyword">this</span>->age &lt;&lt; std::endl;
    }

    <span class="comment">// Static method</span>
    <span class="keyword">static</span> <span class="keyword">int</span> <span class="function">getCount</span>() { <span class="keyword">return</span> count; }
};

<span class="comment">// Initialize static member</span>
<span class="keyword">int</span> Person::count = <span class="number">0</span>;

<span class="keyword">int</span> <span class="function">main</span>() {
    Person p1;                       <span class="comment">// Default constructor</span>
    Person p2(<span class="string">"Alice"</span>, <span class="number">25</span>);          <span class="comment">// Parameterized constructor</span>
    Person* p3 = <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">30</span>);

    p1.setName(<span class="string">"John"</span>);
    p1.introduce();
    p2.introduce();

    std::cout &lt;&lt; <span class="string">"Total persons: "</span> &lt;&lt; Person::getCount() &lt;&lt; std::endl;

    <span class="keyword">delete</span> p3;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Strings -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìù Strings</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="beginner">
                        <li><input type="checkbox" id="b41"><label for="b41">C-style strings (char arrays)</label></li>
                        <li><input type="checkbox" id="b42"><label for="b42">std::string basics</label></li>
                        <li><input type="checkbox" id="b43"><label for="b43">String operations and methods</label></li>
                        <li><input type="checkbox" id="b44"><label for="b44">String input/output</label></li>
                    </ul>

                    <div class="code-header">
                        <span>strings.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;cstring&gt;</span>  <span class="comment">// For C-style string functions</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// C-style string</span>
    <span class="keyword">char</span> cStr[] = <span class="string">"Hello"</span>;
    std::cout &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; strlen(cStr) &lt;&lt; std::endl;

    <span class="comment">// std::string (preferred in C++)</span>
    std::string str1 = <span class="string">"Hello"</span>;
    std::string str2 = <span class="string">"World"</span>;

    <span class="comment">// Concatenation</span>
    std::string combined = str1 + <span class="string">" "</span> + str2;

    <span class="comment">// String methods</span>
    std::cout &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; combined.length() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"Char at 0: "</span> &lt;&lt; combined[<span class="number">0</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"Substring: "</span> &lt;&lt; combined.substr(<span class="number">0</span>, <span class="number">5</span>) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"Find 'World': "</span> &lt;&lt; combined.find(<span class="string">"World"</span>) &lt;&lt; std::endl;

    <span class="comment">// String comparison</span>
    <span class="keyword">if</span> (str1 == <span class="string">"Hello"</span>) {
        std::cout &lt;&lt; <span class="string">"Strings are equal"</span> &lt;&lt; std::endl;
    }

    <span class="comment">// String modification</span>
    str1.append(<span class="string">"!"</span>);
    str1.insert(<span class="number">5</span>, <span class="string">" there"</span>);
    str1.replace(<span class="number">0</span>, <span class="number">5</span>, <span class="string">"Hi"</span>);

    <span class="comment">// Reading strings</span>
    std::string input;
    std::cout &lt;&lt; <span class="string">"Enter name: "</span>;
    std::getline(std::cin, input);  <span class="comment">// Read entire line</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>
        </section>

        <!-- ==================== INTERMEDIATE SECTION ==================== -->
        <section id="intermediate">
            <h2>üìô Intermediate Level - Object-Oriented Programming <span class="badge badge-intermediate">Intermediate</span></h2>

            <div class="info">
                <div>Build upon your fundamentals with advanced OOP concepts, templates, and the Standard Template Library (STL).</div>
            </div>

            <!-- Inheritance -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üß¨ Inheritance</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Classes, constructors/destructors, access specifiers<br>
                            <strong>üéØ Learning Objectives:</strong> Implement inheritance hierarchies, understand virtual destructors, handle multiple inheritance<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 3-4 hours<br>
                            <strong>üîÑ Coming from Other Languages:</strong> C++ supports true multiple inheritance (not just interfaces), and has explicit access control on inheritance itself
                        </div>
                    </div>

                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i1"><label for="i1">Single inheritance</label></li>
                        <li><input type="checkbox" id="i2"><label for="i2">Multiple inheritance</label></li>
                        <li><input type="checkbox" id="i3"><label for="i3">Access specifiers in inheritance</label></li>
                        <li><input type="checkbox" id="i4"><label for="i4">Virtual inheritance (diamond problem)</label></li>
                        <li><input type="checkbox" id="i5"><label for="i5">Constructor/destructor order</label></li>
                    </ul>

                    <h4>üîÑ Inheritance: C++ vs Java vs Python</h4>
                    <table>
                        <tr><th>Feature</th><th>Java</th><th>Python</th><th>C++</th></tr>
                        <tr><td><strong>Syntax</strong></td><td><code>class Dog extends Animal</code></td><td><code>class Dog(Animal):</code></td><td><code>class Dog : public Animal</code></td></tr>
                        <tr><td><strong>Multiple inheritance</strong></td><td>No (interfaces only)</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td><strong>Inheritance access</strong></td><td>Always public</td><td>No concept</td><td>public/protected/private</td></tr>
                        <tr><td><strong>Virtual by default?</strong></td><td>Yes (all methods)</td><td>Yes (all methods)</td><td>No (must mark <code>virtual</code>)</td></tr>
                        <tr><td><strong>Super call</strong></td><td><code>super.method()</code></td><td><code>super().method()</code></td><td><code>Base::method()</code></td></tr>
                        <tr><td><strong>Diamond problem</strong></td><td>N/A</td><td>MRO (C3 linearization)</td><td>Virtual inheritance</td></tr>
                    </table>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Critical: Virtual Destructors!</strong> Unlike Java, C++ destructors are NOT virtual by default. If you have a base class pointer to a derived object and call <code>delete</code>, without <code>virtual ~Base()</code>, only the base destructor runs - memory leak! <strong>Rule:</strong> If a class might be inherited, make its destructor virtual.</div>
                    </div>

                    <div class="code-header">
                        <span>inheritance_comparison.cpp</span>
                        <span class="lang-badge">Cross-Language</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA INHERITANCE ============</span>
<span class="comment">// class Dog extends Animal { }  // Always public inheritance</span>
<span class="comment">// All methods virtual by default - no explicit marking needed</span>

<span class="comment">// ============ PYTHON INHERITANCE ============</span>
<span class="comment">// class Dog(Animal):  # Multiple bases allowed: class Dog(Animal, Pet)</span>
<span class="comment">//     pass  # All methods overrideable by default</span>

<span class="comment">// ============ C++ INHERITANCE ============</span>
<span class="keyword">class</span> <span class="type">Dog</span> : <span class="keyword">public</span> Animal {    <span class="comment">// public inheritance (like Java)</span>
    <span class="comment">// protected ‚Üí protected, public ‚Üí public in derived</span>
};

<span class="keyword">class</span> <span class="type">Dog</span> : <span class="keyword">private</span> Animal {   <span class="comment">// private inheritance (composition-like)</span>
    <span class="comment">// ALL base members become private - implementation inheritance</span>
};

<span class="comment">// WHY INHERITANCE ACCESS MATTERS:</span>
<span class="comment">// public    = "is-a" relationship (Dog IS an Animal)</span>
<span class="comment">// private   = "implemented-in-terms-of" (uses internally)</span>
<span class="comment">// protected = rarely used (for further derivation only)</span>
</code></pre>

                    <div class="code-header">
                        <span>inheritance.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Base class</span>
<span class="keyword">class</span> <span class="type">Animal</span> {
<span class="keyword">protected</span>:
    std::string name;
<span class="keyword">public</span>:
    <span class="function">Animal</span>(<span class="keyword">const</span> std::string& n) : name(n) {
        std::cout &lt;&lt; <span class="string">"Animal constructor"</span> &lt;&lt; std::endl;
    }
    <span class="keyword">virtual</span> <span class="function">~Animal</span>() {
        std::cout &lt;&lt; <span class="string">"Animal destructor"</span> &lt;&lt; std::endl;
    }
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">speak</span>() <span class="keyword">const</span> {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">" makes a sound"</span> &lt;&lt; std::endl;
    }
};

<span class="comment">// Derived class</span>
<span class="keyword">class</span> <span class="type">Dog</span> : <span class="keyword">public</span> Animal {
<span class="keyword">private</span>:
    std::string breed;
<span class="keyword">public</span>:
    <span class="function">Dog</span>(<span class="keyword">const</span> std::string& n, <span class="keyword">const</span> std::string& b)
        : Animal(n), breed(b) {
        std::cout &lt;&lt; <span class="string">"Dog constructor"</span> &lt;&lt; std::endl;
    }
    <span class="function">~Dog</span>() <span class="keyword">override</span> {
        std::cout &lt;&lt; <span class="string">"Dog destructor"</span> &lt;&lt; std::endl;
    }
    <span class="keyword">void</span> <span class="function">speak</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">" barks!"</span> &lt;&lt; std::endl;
    }
};

<span class="comment">// Multiple inheritance</span>
<span class="keyword">class</span> <span class="type">Flyable</span> {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">fly</span>() = <span class="number">0</span>;  <span class="comment">// Pure virtual</span>
};

<span class="keyword">class</span> <span class="type">Bird</span> : <span class="keyword">public</span> Animal, <span class="keyword">public</span> Flyable {
<span class="keyword">public</span>:
    <span class="function">Bird</span>(<span class="keyword">const</span> std::string& n) : Animal(n) {}
    <span class="keyword">void</span> <span class="function">speak</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">" chirps!"</span> &lt;&lt; std::endl;
    }
    <span class="keyword">void</span> <span class="function">fly</span>() <span class="keyword">override</span> {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">" is flying!"</span> &lt;&lt; std::endl;
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Polymorphism with base pointer</span>
    Animal* animal = <span class="keyword">new</span> Dog(<span class="string">"Rex"</span>, <span class="string">"German Shepherd"</span>);
    animal->speak();  <span class="comment">// Calls Dog::speak()</span>
    <span class="keyword">delete</span> animal;    <span class="comment">// Proper cleanup due to virtual destructor</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Polymorphism -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üé≠ Polymorphism</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i6"><label for="i6">Compile-time polymorphism (overloading)</label></li>
                        <li><input type="checkbox" id="i7"><label for="i7">Runtime polymorphism (virtual functions)</label></li>
                        <li><input type="checkbox" id="i8"><label for="i8">Pure virtual functions and abstract classes</label></li>
                        <li><input type="checkbox" id="i9"><label for="i9">Virtual tables (vtable) concept</label></li>
                        <li><input type="checkbox" id="i10"><label for="i10">override and final specifiers (C++11)</label></li>
                    </ul>

                    <div class="code-header">
                        <span>polymorphism.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;memory&gt;</span>

<span class="comment">// Abstract base class (interface)</span>
<span class="keyword">class</span> <span class="type">Shape</span> {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="function">~Shape</span>() = <span class="keyword">default</span>;
    <span class="keyword">virtual</span> <span class="keyword">double</span> <span class="function">area</span>() <span class="keyword">const</span> = <span class="number">0</span>;      <span class="comment">// Pure virtual</span>
    <span class="keyword">virtual</span> <span class="keyword">double</span> <span class="function">perimeter</span>() <span class="keyword">const</span> = <span class="number">0</span>; <span class="comment">// Pure virtual</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">draw</span>() <span class="keyword">const</span> = <span class="number">0</span>;
};

<span class="keyword">class</span> <span class="type">Circle</span> : <span class="keyword">public</span> Shape {
<span class="keyword">private</span>:
    <span class="keyword">double</span> radius;
<span class="keyword">public</span>:
    <span class="keyword">explicit</span> <span class="function">Circle</span>(<span class="keyword">double</span> r) : radius(r) {}

    <span class="keyword">double</span> <span class="function">area</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;
    }
    <span class="keyword">double</span> <span class="function">perimeter</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14159</span> * radius;
    }
    <span class="keyword">void</span> <span class="function">draw</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        std::cout &lt;&lt; <span class="string">"Drawing circle with radius "</span> &lt;&lt; radius &lt;&lt; std::endl;
    }
};

<span class="keyword">class</span> <span class="type">Rectangle</span> : <span class="keyword">public</span> Shape {
<span class="keyword">private</span>:
    <span class="keyword">double</span> width, height;
<span class="keyword">public</span>:
    <span class="function">Rectangle</span>(<span class="keyword">double</span> w, <span class="keyword">double</span> h) : width(w), height(h) {}

    <span class="keyword">double</span> <span class="function">area</span>() <span class="keyword">const</span> <span class="keyword">override</span> { <span class="keyword">return</span> width * height; }
    <span class="keyword">double</span> <span class="function">perimeter</span>() <span class="keyword">const</span> <span class="keyword">override</span> { <span class="keyword">return</span> <span class="number">2</span> * (width + height); }
    <span class="keyword">void</span> <span class="function">draw</span>() <span class="keyword">const</span> <span class="keyword">override</span> {
        std::cout &lt;&lt; <span class="string">"Drawing rectangle "</span> &lt;&lt; width &lt;&lt; <span class="string">"x"</span> &lt;&lt; height &lt;&lt; std::endl;
    }
};

<span class="comment">// Final class - cannot be inherited</span>
<span class="keyword">class</span> <span class="type">Square</span> <span class="keyword">final</span> : <span class="keyword">public</span> Rectangle {
<span class="keyword">public</span>:
    <span class="keyword">explicit</span> <span class="function">Square</span>(<span class="keyword">double</span> side) : Rectangle(side, side) {}
};

<span class="keyword">int</span> <span class="function">main</span>() {
    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;
    shapes.push_back(std::make_unique&lt;Circle&gt;(<span class="number">5.0</span>));
    shapes.push_back(std::make_unique&lt;Rectangle&gt;(<span class="number">4.0</span>, <span class="number">6.0</span>));
    shapes.push_back(std::make_unique&lt;Square&gt;(<span class="number">3.0</span>));

    <span class="comment">// Polymorphic behavior</span>
    <span class="keyword">for</span> (<span class="keyword">const auto</span>& shape : shapes) {
        shape->draw();
        std::cout &lt;&lt; <span class="string">"Area: "</span> &lt;&lt; shape->area() &lt;&lt; std::endl;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="tip">
                        <div><strong>Best Practice:</strong> Always make destructors virtual in base classes. Use <code>override</code> keyword to catch errors at compile time.</div>
                    </div>
                </div>
            </div>

            <!-- Operator Overloading -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>‚ûï Operator Overloading</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i11"><label for="i11">Overloading arithmetic operators</label></li>
                        <li><input type="checkbox" id="i12"><label for="i12">Overloading comparison operators</label></li>
                        <li><input type="checkbox" id="i13"><label for="i13">Overloading stream operators (<<, >>)</label></li>
                        <li><input type="checkbox" id="i14"><label for="i14">Overloading subscript operator []</label></li>
                        <li><input type="checkbox" id="i15"><label for="i15">Overloading function call operator ()</label></li>
                    </ul>

                    <div class="code-header">
                        <span>operator_overloading.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">class</span> <span class="type">Vector2D</span> {
<span class="keyword">private</span>:
    <span class="keyword">double</span> x, y;
<span class="keyword">public</span>:
    <span class="function">Vector2D</span>(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) {}

    <span class="comment">// Arithmetic operators</span>
    Vector2D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2D& other) <span class="keyword">const</span> {
        <span class="keyword">return</span> Vector2D(x + other.x, y + other.y);
    }

    Vector2D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector2D& other) <span class="keyword">const</span> {
        <span class="keyword">return</span> Vector2D(x - other.x, y - other.y);
    }

    Vector2D <span class="keyword">operator</span>*(<span class="keyword">double</span> scalar) <span class="keyword">const</span> {
        <span class="keyword">return</span> Vector2D(x * scalar, y * scalar);
    }

    <span class="comment">// Compound assignment</span>
    Vector2D& <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector2D& other) {
        x += other.x;
        y += other.y;
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    <span class="comment">// Comparison operators</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2D& other) <span class="keyword">const</span> {
        <span class="keyword">return</span> x == other.x && y == other.y;
    }

    <span class="comment">// Subscript operator</span>
    <span class="keyword">double</span>& <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {
        <span class="keyword">return</span> (index == <span class="number">0</span>) ? x : y;
    }

    <span class="comment">// Stream operator (friend function)</span>
    <span class="keyword">friend</span> std::ostream& <span class="keyword">operator</span>&lt;&lt;(std::ostream& os, <span class="keyword">const</span> Vector2D& v) {
        os &lt;&lt; <span class="string">"("</span> &lt;&lt; v.x &lt;&lt; <span class="string">", "</span> &lt;&lt; v.y &lt;&lt; <span class="string">")"</span>;
        <span class="keyword">return</span> os;
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    Vector2D v1(<span class="number">3</span>, <span class="number">4</span>), v2(<span class="number">1</span>, <span class="number">2</span>);

    std::cout &lt;&lt; <span class="string">"v1: "</span> &lt;&lt; v1 &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"v1 + v2: "</span> &lt;&lt; (v1 + v2) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"v1 * 2: "</span> &lt;&lt; (v1 * <span class="number">2</span>) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"v1[0]: "</span> &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; std::endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Templates -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìê Templates and Generic Programming</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Functions, classes, basic type system<br>
                            <strong>üéØ Learning Objectives:</strong> Write type-generic code, understand compile-time polymorphism<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 5-7 hours<br>
                            <strong>üîó Connects To:</strong> STL, Metaprogramming, Concepts (C++20)<br>
                            <strong>üîÑ Coming from Other Languages:</strong> Templates are NOT generics! They're far more powerful (and complex)
                        </div>
                    </div>

                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i16"><label for="i16">Function templates</label></li>
                        <li><input type="checkbox" id="i17"><label for="i17">Class templates</label></li>
                        <li><input type="checkbox" id="i18"><label for="i18">Template specialization</label></li>
                        <li><input type="checkbox" id="i19"><label for="i19">Variadic templates (C++11)</label></li>
                        <li><input type="checkbox" id="i20"><label for="i20">SFINAE basics</label></li>
                    </ul>

                    <h4>üîÑ Templates vs Generics: The Critical Difference</h4>
                    <p>If you're coming from Java, C#, or TypeScript, you might think templates are like generics. <strong>They're fundamentally different:</strong></p>

                    <table>
                        <tr><th>Aspect</th><th>Java/C# Generics</th><th>C++ Templates</th></tr>
                        <tr><td><strong>When resolved?</strong></td><td>Runtime (type erasure in Java)</td><td>Compile-time (code generation)</td></tr>
                        <tr><td><strong>Type constraints?</strong></td><td><code>extends</code>/<code>where</code> clauses</td><td>SFINAE, Concepts (C++20)</td></tr>
                        <tr><td><strong>Can use non-types?</strong></td><td>No</td><td>Yes! <code>template&lt;int N&gt;</code></td></tr>
                        <tr><td><strong>Specialization?</strong></td><td>No</td><td>Yes - full and partial</td></tr>
                        <tr><td><strong>Code generated?</strong></td><td>One version for all types</td><td>New code for each type used</td></tr>
                        <tr><td><strong>Error messages?</strong></td><td>Clear, at use site</td><td>Often cryptic, in template body</td></tr>
                        <tr><td><strong>Turing complete?</strong></td><td>No</td><td>Yes (metaprogramming)</td></tr>
                    </table>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Key Difference:</strong> In Java, <code>List&lt;Integer&gt;</code> and <code>List&lt;String&gt;</code> are the SAME class at runtime (type erasure). In C++, <code>vector&lt;int&gt;</code> and <code>vector&lt;string&gt;</code> are DIFFERENT classes - the compiler generates separate code for each!</div>
                    </div>

                    <h4>Cross-Language Comparison</h4>
                    <div class="code-header">
                        <span>Templates vs Generics Comparison</span>
                        <span class="lang-badge">Cross-Language</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA GENERICS ============</span>
<span class="comment">// public &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T a, T b) {</span>
<span class="comment">//     return a.compareTo(b) &gt; 0 ? a : b;</span>
<span class="comment">// }</span>
<span class="comment">// - Runtime type erasure: T becomes Object</span>
<span class="comment">// - Cannot use primitives: maximum(1, 2) needs Integer boxing</span>
<span class="comment">// - Single compiled method for all types</span>

<span class="comment">// ============ PYTHON (Duck Typing) ============</span>
<span class="comment">// def maximum(a, b):</span>
<span class="comment">//     return a if a &gt; b else b</span>
<span class="comment">// - No types at all - works if __gt__ exists</span>
<span class="comment">// - Runtime error if incompatible types</span>

<span class="comment">// ============ C++ TEMPLATES ============</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
T <span class="function">maximum</span>(T a, T b) {
    <span class="keyword">return</span> (a > b) ? a : b;  <span class="comment">// Requires operator&gt;</span>
}
<span class="comment">// - Compile-time: generates maximum&lt;int&gt;, maximum&lt;double&gt;, etc.</span>
<span class="comment">// - Works with primitives directly: maximum(1, 2) - no boxing!</span>
<span class="comment">// - Compile error if T doesn't support operator&gt;</span>
<span class="comment">// - Each instantiation is separately optimized code</span>
</code></pre>

                    <h4>The Power of Non-Type Template Parameters</h4>
                    <p><strong>Unique to C++:</strong> Template parameters can be values, not just types. This enables compile-time computation that Java/C# generics cannot do.</p>

                    <div class="code-header">
                        <span>non_type_templates.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// Size known at compile time - can be on stack!</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;
<span class="keyword">class</span> <span class="type">FixedArray</span> {
    T data[Size];  <span class="comment">// Stack allocation - no heap, no GC equivalent</span>
<span class="keyword">public</span>:
    <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="function">size</span>() <span class="keyword">const</span> { <span class="keyword">return</span> Size; }
    T& <span class="keyword">operator</span>[](<span class="keyword">int</span> i) { <span class="keyword">return</span> data[i]; }
};

<span class="comment">// Java CANNOT do this - array size must be runtime:</span>
<span class="comment">// class FixedArray&lt;T, int Size&gt; { } // INVALID JAVA!</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    FixedArray&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; arr;  <span class="comment">// 400 bytes on stack, zero heap allocation</span>
    <span class="comment">// In Java: new int[100] ALWAYS goes to heap, needs GC</span>

    <span class="comment">// Compile-time size checking</span>
    <span class="keyword">static_assert</span>(FixedArray&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt;().size() == <span class="number">100</span>);  <span class="comment">// Checked at compile time!</span>
}
</code></pre>

                    <h4>Template Specialization - Impossible in Java</h4>
                    <div class="code-header">
                        <span>template_specialization.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="comment">// General template</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">class</span> <span class="type">Serializer</span> {
<span class="keyword">public</span>:
    <span class="keyword">static</span> std::string <span class="function">serialize</span>(<span class="keyword">const</span> T& obj) {
        <span class="keyword">return</span> <span class="string">"generic serialization"</span>;
    }
};

<span class="comment">// Specialization for std::string - completely different implementation</span>
<span class="keyword">template</span>&lt;&gt;
<span class="keyword">class</span> <span class="type">Serializer</span>&lt;std::string&gt; {
<span class="keyword">public</span>:
    <span class="keyword">static</span> std::string <span class="function">serialize</span>(<span class="keyword">const</span> std::string& str) {
        <span class="keyword">return</span> <span class="string">"\"" + str + "\""</span>;  <span class="comment">// JSON-style string</span>
    }
};

<span class="comment">// Partial specialization for pointers</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">class</span> <span class="type">Serializer</span>&lt;T*&gt; {
<span class="keyword">public</span>:
    <span class="keyword">static</span> std::string <span class="function">serialize</span>(T* ptr) {
        <span class="keyword">return</span> ptr ? Serializer&lt;T&gt;::serialize(*ptr) : <span class="string">"null"</span>;
    }
};

<span class="comment">// In Java, you'd need runtime instanceof checks:</span>
<span class="comment">// if (obj instanceof String) { ... } else if (obj == null) { ... }</span>
<span class="comment">// C++ does this at COMPILE TIME with zero runtime overhead</span>
</code></pre>

                    <div class="info">
                        <div><strong>üí° Why This Matters:</strong> Template specialization is how the STL achieves both genericity AND optimal performance. <code>std::vector&lt;bool&gt;</code> is completely different from <code>std::vector&lt;int&gt;</code> - specialized for space efficiency. This would require runtime checks in Java.</div>
                    </div>

                    <h4>Basic Templates Example</h4>
                    <div class="code-header">
                        <span>templates.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="comment">// Function template</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
T <span class="function">maximum</span>(T a, T b) {
    <span class="keyword">return</span> (a > b) ? a : b;
}

<span class="comment">// Class template with non-type parameter</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;
<span class="keyword">class</span> <span class="type">Array</span> {
<span class="keyword">private</span>:
    T data[Size];
<span class="keyword">public</span>:
    T& <span class="keyword">operator</span>[](<span class="keyword">int</span> index) { <span class="keyword">return</span> data[index]; }
    <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="function">size</span>() <span class="keyword">const</span> { <span class="keyword">return</span> Size; }
};

<span class="comment">// Template specialization for string</span>
<span class="keyword">template</span>&lt;&gt;
std::string <span class="function">maximum</span>&lt;std::string&gt;(std::string a, std::string b) {
    <span class="keyword">return</span> (a.length() > b.length()) ? a : b;  <span class="comment">// Compare by length instead</span>
}

<span class="comment">// Variadic template (C++11) - arbitrary number of arguments</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;
<span class="keyword">void</span> <span class="function">print</span>(Args... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;  <span class="comment">// Fold expression (C++17)</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Type deduction - compiler figures out T</span>
    std::cout &lt;&lt; maximum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;       <span class="comment">// T = int</span>
    std::cout &lt;&lt; maximum(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl;  <span class="comment">// T = double</span>

    <span class="comment">// Explicit template argument</span>
    std::cout &lt;&lt; maximum&lt;std::string&gt;(<span class="string">"hi"</span>, <span class="string">"hello"</span>) &lt;&lt; std::endl;

    <span class="comment">// Non-type template parameter</span>
    Array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; arr;  <span class="comment">// Fixed-size array on stack</span>
    arr[<span class="number">0</span>] = <span class="number">100</span>;

    <span class="comment">// Variadic template</span>
    print(<span class="string">"Answer: "</span>, <span class="number">42</span>, <span class="string">", Pi: "</span>, <span class="number">3.14</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>‚ö†Ô∏è Common Pitfalls for Java/C# Developers</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üî¥ Template code in headers</h5>
                            <p>Templates must be in headers (or visible at instantiation). Unlike Java, can't separate declaration from definition in different files easily.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Error messages</h5>
                            <p>Template errors are notoriously cryptic. Use C++20 Concepts or static_assert for better errors.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Code bloat</h5>
                            <p>Each instantiation generates new code. <code>vector&lt;int&gt;</code>, <code>vector&lt;long&gt;</code>, <code>vector&lt;double&gt;</code> = 3x the code.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ No runtime type info</h5>
                            <p>Can't do <code>instanceof</code> or get type at runtime. Everything resolved at compile time.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- STL -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìö STL Containers and Algorithms</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Templates basics, pointers/references, iterators concept<br>
                            <strong>üéØ Learning Objectives:</strong> Master standard containers, choose the right container for each use case, use STL algorithms effectively<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 6-8 hours<br>
                            <strong>üîó Connects To:</strong> Templates, Iterators, Lambdas, Time Complexity Analysis
                        </div>
                    </div>

                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i21"><label for="i21">vector, array, deque</label></li>
                        <li><input type="checkbox" id="i22"><label for="i22">list, forward_list</label></li>
                        <li><input type="checkbox" id="i23"><label for="i23">set, multiset, unordered_set</label></li>
                        <li><input type="checkbox" id="i24"><label for="i24">map, multimap, unordered_map</label></li>
                        <li><input type="checkbox" id="i25"><label for="i25">stack, queue, priority_queue</label></li>
                        <li><input type="checkbox" id="i26"><label for="i26">Iterators</label></li>
                        <li><input type="checkbox" id="i27"><label for="i27">Common algorithms (sort, find, transform, etc.)</label></li>
                    </ul>

                    <h4>What is the STL?</h4>
                    <p>The <strong>Standard Template Library (STL)</strong> is a collection of template classes and functions providing common data structures and algorithms. It's one of C++'s most powerful features, offering battle-tested, highly optimized implementations.</p>

                    <h4>Container Selection Guide</h4>
                    <table>
                        <tr><th>Container</th><th>Access</th><th>Insert/Delete</th><th>Best For</th></tr>
                        <tr><td><code>vector</code></td><td>O(1) random</td><td>O(1) back, O(n) middle</td><td>Default choice, sequential data</td></tr>
                        <tr><td><code>deque</code></td><td>O(1) random</td><td>O(1) front/back</td><td>Queue operations, both ends</td></tr>
                        <tr><td><code>list</code></td><td>O(n) sequential</td><td>O(1) anywhere</td><td>Frequent insertions/deletions</td></tr>
                        <tr><td><code>set</code></td><td>O(log n)</td><td>O(log n)</td><td>Unique sorted elements</td></tr>
                        <tr><td><code>unordered_set</code></td><td>O(1) average</td><td>O(1) average</td><td>Fast lookup, no ordering needed</td></tr>
                        <tr><td><code>map</code></td><td>O(log n)</td><td>O(log n)</td><td>Key-value pairs, sorted keys</td></tr>
                        <tr><td><code>unordered_map</code></td><td>O(1) average</td><td>O(1) average</td><td>Fast key-value lookup</td></tr>
                    </table>

                    <h4>Sequence Containers - Detailed Examples</h4>
                    <div class="code-header">
                        <span>stl_sequences.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;deque&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;list&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;array&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ VECTOR - Your Default Choice ============</span>
    <span class="comment">// Dynamic array - contiguous memory, cache-friendly</span>
    std::vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};

    vec.push_back(<span class="number">4</span>);           <span class="comment">// Add to end - O(1) amortized</span>
    vec.emplace_back(<span class="number">5</span>);        <span class="comment">// Construct in-place (more efficient)</span>
    vec.pop_back();             <span class="comment">// Remove last element</span>

    vec.reserve(<span class="number">100</span>);           <span class="comment">// Pre-allocate to avoid reallocations</span>
    vec.shrink_to_fit();        <span class="comment">// Release unused memory</span>

    <span class="comment">// Access methods</span>
    <span class="keyword">int</span> first = vec[<span class="number">0</span>];         <span class="comment">// No bounds checking (fast but dangerous)</span>
    <span class="keyword">int</span> safe = vec.at(<span class="number">0</span>);       <span class="comment">// Throws std::out_of_range if invalid</span>
    <span class="keyword">int</span> front = vec.front();    <span class="comment">// First element</span>
    <span class="keyword">int</span> back = vec.back();      <span class="comment">// Last element</span>

    <span class="comment">// ============ DEQUE - Double-ended Queue ============</span>
    <span class="comment">// Fast insert/remove at both ends, random access</span>
    std::deque&lt;<span class="keyword">int</span>&gt; dq = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};
    dq.push_front(<span class="number">1</span>);  <span class="comment">// O(1) - unlike vector!</span>
    dq.push_back(<span class="number">5</span>);
    dq.pop_front();

    <span class="comment">// ============ LIST - Doubly Linked List ============</span>
    <span class="comment">// Fast insert/delete anywhere, no random access</span>
    std::list&lt;<span class="keyword">int</span>&gt; lst = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>};
    <span class="keyword">auto</span> it = lst.begin();
    std::advance(it, <span class="number">1</span>);     <span class="comment">// Move iterator to position 1</span>
    lst.insert(it, <span class="number">2</span>);       <span class="comment">// Insert 2 before position 1</span>

    lst.remove(<span class="number">3</span>);            <span class="comment">// Remove all elements with value 3</span>
    lst.sort();              <span class="comment">// List has its own sort (can't use std::sort)</span>
    lst.unique();            <span class="comment">// Remove consecutive duplicates</span>
    lst.merge(other_list);   <span class="comment">// Merge two sorted lists</span>

    <span class="comment">// ============ ARRAY - Fixed Size ============</span>
    std::array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    <span class="comment">// Size is compile-time constant - can use with templates</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Associative Containers - Maps and Sets</h4>
                    <div class="code-header">
                        <span>stl_associative.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;map&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;unordered_map&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;set&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ MAP - Sorted Key-Value Pairs ============</span>
    std::map&lt;std::string, <span class="keyword">int</span>&gt; ages;

    <span class="comment">// Insertion methods</span>
    ages[<span class="string">"Alice"</span>] = <span class="number">25</span>;           <span class="comment">// Creates if not exists</span>
    ages.insert({<span class="string">"Bob"</span>, <span class="number">30</span>});    <span class="comment">// Won't overwrite existing</span>
    ages.emplace(<span class="string">"Charlie"</span>, <span class="number">35</span>); <span class="comment">// Construct in-place</span>

    <span class="comment">// Safe access - check before accessing</span>
    <span class="keyword">if</span> (ages.find(<span class="string">"Alice"</span>) != ages.end()) {
        std::cout &lt;&lt; ages[<span class="string">"Alice"</span>] &lt;&lt; std::endl;
    }

    <span class="comment">// C++20: contains() method</span>
    <span class="keyword">if</span> (ages.contains(<span class="string">"Bob"</span>)) { <span class="comment">/* ... */</span> }

    <span class="comment">// Iteration (keys are sorted!)</span>
    <span class="keyword">for</span> (<span class="keyword">const auto</span>& [name, age] : ages) {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">": "</span> &lt;&lt; age &lt;&lt; std::endl;
    }

    <span class="comment">// ============ UNORDERED_MAP - Hash Table ============</span>
    <span class="comment">// Faster average case O(1), but unordered</span>
    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; scores;
    scores[<span class="string">"team1"</span>] = <span class="number">100</span>;
    scores[<span class="string">"team2"</span>] = <span class="number">85</span>;

    <span class="comment">// ============ SET - Unique Sorted Elements ============</span>
    std::set&lt;<span class="keyword">int</span>&gt; uniqueNums;
    uniqueNums.insert(<span class="number">5</span>);
    uniqueNums.insert(<span class="number">3</span>);
    uniqueNums.insert(<span class="number">5</span>);  <span class="comment">// Duplicate - ignored!</span>
    <span class="comment">// Set contains: {3, 5}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>Essential STL Algorithms</h4>
                    <div class="code-header">
                        <span>stl_algorithms.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;algorithm&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;numeric&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    std::vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>};

    <span class="comment">// Sorting</span>
    std::sort(v.begin(), v.end());                    <span class="comment">// Ascending</span>
    std::sort(v.begin(), v.end(), std::greater&lt;&gt;());  <span class="comment">// Descending</span>

    <span class="comment">// Searching (on sorted range)</span>
    <span class="keyword">bool</span> found = std::binary_search(v.begin(), v.end(), <span class="number">5</span>);
    <span class="keyword">auto</span> it = std::lower_bound(v.begin(), v.end(), <span class="number">5</span>);  <span class="comment">// First >= 5</span>

    <span class="comment">// Find (unsorted)</span>
    <span class="keyword">auto</span> pos = std::find(v.begin(), v.end(), <span class="number">8</span>);
    <span class="keyword">auto</span> pos2 = std::find_if(v.begin(), v.end(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x > <span class="number">5</span>; });

    <span class="comment">// Count</span>
    <span class="keyword">int</span> count = std::count(v.begin(), v.end(), <span class="number">5</span>);
    <span class="keyword">int</span> countIf = std::count_if(v.begin(), v.end(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; });

    <span class="comment">// Transform - apply function to each element</span>
    std::vector&lt;<span class="keyword">int</span>&gt; squared(v.size());
    std::transform(v.begin(), v.end(), squared.begin(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x * x; });

    <span class="comment">// Accumulate - reduce/fold</span>
    <span class="keyword">int</span> sum = std::accumulate(v.begin(), v.end(), <span class="number">0</span>);
    <span class="keyword">int</span> product = std::accumulate(v.begin(), v.end(), <span class="number">1</span>, std::multiplies&lt;&gt;());

    <span class="comment">// Min/Max</span>
    <span class="keyword">auto</span> [minIt, maxIt] = std::minmax_element(v.begin(), v.end());

    <span class="comment">// Remove (doesn't actually erase - use erase-remove idiom)</span>
    v.erase(std::remove(v.begin(), v.end(), <span class="number">5</span>), v.end());

    <span class="comment">// Reverse, rotate, shuffle</span>
    std::reverse(v.begin(), v.end());
    std::rotate(v.begin(), v.begin() + <span class="number">2</span>, v.end());

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Common Pitfalls:</strong><br>
                        ‚Ä¢ <strong>Iterator invalidation:</strong> Modifying a container while iterating can invalidate iterators<br>
                        ‚Ä¢ <strong>operator[] on map:</strong> Creates entry if key doesn't exist! Use <code>find()</code> or <code>at()</code><br>
                        ‚Ä¢ <strong>Sorting non-random-access:</strong> <code>std::sort</code> won't work on <code>list</code> - use <code>list.sort()</code></div>
                    </div>

                    <div class="video-section">
                        <h4>Recommended STL Videos</h4>
                        <div class="video-grid">
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>C++ STL Tutorial</h5>
                                    <p class="channel">The Cherno</p>
                                    <a href="https://www.youtube.com/watch?v=LyGlTmaWEPs" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Exception Handling -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>‚ö†Ô∏è Exception Handling</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="intermediate">
                        <li><input type="checkbox" id="i28"><label for="i28">try, catch, throw</label></li>
                        <li><input type="checkbox" id="i29"><label for="i29">Standard exceptions</label></li>
                        <li><input type="checkbox" id="i30"><label for="i30">Custom exception classes</label></li>
                        <li><input type="checkbox" id="i31"><label for="i31">Exception safety guarantees</label></li>
                        <li><input type="checkbox" id="i32"><label for="i32">noexcept specifier</label></li>
                    </ul>

                    <div class="code-header">
                        <span>exceptions.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;stdexcept&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>

<span class="comment">// Custom exception</span>
<span class="keyword">class</span> <span class="type">ValidationError</span> : <span class="keyword">public</span> std::runtime_error {
<span class="keyword">public</span>:
    <span class="keyword">explicit</span> <span class="function">ValidationError</span>(<span class="keyword">const</span> std::string& msg)
        : std::runtime_error(msg) {}
};

<span class="keyword">double</span> <span class="function">divide</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {
    <span class="keyword">if</span> (b == <span class="number">0</span>) {
        <span class="keyword">throw</span> std::invalid_argument(<span class="string">"Division by zero"</span>);
    }
    <span class="keyword">return</span> a / b;
}

<span class="keyword">void</span> <span class="function">validateAge</span>(<span class="keyword">int</span> age) {
    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age > <span class="number">150</span>) {
        <span class="keyword">throw</span> ValidationError(<span class="string">"Invalid age: "</span> + std::to_string(age));
    }
}

<span class="comment">// noexcept - promises not to throw</span>
<span class="keyword">int</span> <span class="function">safeAdd</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) <span class="keyword">noexcept</span> {
    <span class="keyword">return</span> a + b;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">try</span> {
        std::cout &lt;&lt; divide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; std::endl;
    } <span class="keyword">catch</span> (<span class="keyword">const</span> std::invalid_argument& e) {
        std::cerr &lt;&lt; <span class="string">"Error: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
    } <span class="keyword">catch</span> (<span class="keyword">const</span> std::exception& e) {
        std::cerr &lt;&lt; <span class="string">"Unexpected error: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
    } <span class="keyword">catch</span> (...) {
        std::cerr &lt;&lt; <span class="string">"Unknown error occurred"</span> &lt;&lt; std::endl;
    }

    <span class="keyword">try</span> {
        validateAge(<span class="number">-5</span>);
    } <span class="keyword">catch</span> (<span class="keyword">const</span> ValidationError& e) {
        std::cerr &lt;&lt; <span class="string">"Validation failed: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>
        </section>

        <!-- ==================== ADVANCED SECTION ==================== -->
        <section id="advanced">
            <h2>üìï Advanced Level - Modern C++ <span class="badge badge-advanced">Advanced</span></h2>

            <div class="note">
                <div>Master modern C++ features from C++11 to C++23. These concepts are essential for writing efficient, safe, and maintainable code.</div>
            </div>

            <!-- Smart Pointers -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üéØ Smart Pointers and Memory Management</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Pointers, dynamic memory (new/delete), constructors/destructors<br>
                            <strong>üéØ Learning Objectives:</strong> Write memory-safe code, understand RAII, eliminate memory leaks<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 4-5 hours<br>
                            <strong>üîó Connects To:</strong> Move semantics, RAII, Exception safety, Rule of Five/Zero<br>
                            <strong>üè≠ Industry Use:</strong> Essential for production C++ - prevents memory leaks, use-after-free, and double-free bugs<br>
                            <strong>üîÑ Coming from Other Languages:</strong> Smart pointers bridge the gap between C++'s manual memory and Java/Python's GC
                        </div>
                    </div>

                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a1"><label for="a1">unique_ptr - exclusive ownership</label></li>
                        <li><input type="checkbox" id="a2"><label for="a2">shared_ptr - shared ownership</label></li>
                        <li><input type="checkbox" id="a3"><label for="a3">weak_ptr - breaking circular references</label></li>
                        <li><input type="checkbox" id="a4"><label for="a4">RAII principle</label></li>
                        <li><input type="checkbox" id="a5"><label for="a5">Custom deleters</label></li>
                    </ul>

                    <h4>üîÑ Smart Pointers vs Garbage Collection: The Fundamental Difference</h4>
                    <p>Coming from Java, Python, or C#? Here's how smart pointers compare to garbage collection:</p>

                    <table>
                        <tr><th>Aspect</th><th>GC (Java/Python/C#)</th><th>C++ Smart Pointers</th></tr>
                        <tr><td><strong>When freed?</strong></td><td>Eventually (GC decides)</td><td>Immediately when last reference dies</td></tr>
                        <tr><td><strong>Predictable timing?</strong></td><td>No (GC pauses)</td><td>Yes (deterministic)</td></tr>
                        <tr><td><strong>Circular refs?</strong></td><td>Handled automatically</td><td>Need weak_ptr to break cycles</td></tr>
                        <tr><td><strong>CPU overhead?</strong></td><td>GC cycles, stop-the-world</td><td>Just reference counting (shared_ptr)</td></tr>
                        <tr><td><strong>Memory overhead?</strong></td><td>Object headers, GC bookkeeping</td><td>None (unique_ptr), control block (shared_ptr)</td></tr>
                        <tr><td><strong>Non-memory resources?</strong></td><td>Need finalizers/dispose</td><td>Destructor handles everything (RAII)</td></tr>
                    </table>

                    <div class="info">
                        <div><strong>üí° Key Insight for Java/C# Developers:</strong> In Java, <code>finalize()</code> is unreliable and <code>try-with-resources</code> only works for explicit scopes. In C++, <em>every</em> object's destructor runs deterministically, making smart pointers more powerful than GC for resource management.</div>
                    </div>

                    <h4>Mapping to Other Languages</h4>
                    <div class="code-header">
                        <span>Conceptual Mapping</span>
                        <span class="lang-badge">Cross-Language</span>
                    </div>
<pre><code><span class="comment">// ============ JAVA EQUIVALENT CONCEPTS ============</span>
<span class="comment">// Java:   Object obj = new Object();  // GC will handle it</span>
<span class="comment">// C++:    auto obj = make_unique&lt;Object&gt;();  // Freed at scope end</span>

<span class="comment">// Java:   WeakReference&lt;Object&gt; weak = new WeakReference&lt;&gt;(obj);</span>
<span class="comment">// C++:    weak_ptr&lt;Object&gt; weak = shared;</span>

<span class="comment">// ============ PYTHON EQUIVALENT CONCEPTS ============</span>
<span class="comment">// Python: obj = Object()  # Reference counted + cyclic GC</span>
<span class="comment">// C++:    auto obj = make_shared&lt;Object&gt;();  # Reference counted only</span>

<span class="comment">// Python: import weakref; weak = weakref.ref(obj)</span>
<span class="comment">// C++:    weak_ptr&lt;Object&gt; weak = shared;</span>

<span class="comment">// ============ C# EQUIVALENT CONCEPTS ============</span>
<span class="comment">// C#:     using (var resource = new Resource()) { ... }</span>
<span class="comment">// C++:    { auto resource = make_unique&lt;Resource&gt;(); ... }</span>
<span class="comment">//         ^ RAII is automatic - no 'using' needed!</span>
</code></pre>

                    <h4>Why Smart Pointers?</h4>
                    <p>Raw pointers are error-prone: you must manually track ownership, remember to delete, and handle exceptions. <strong>Smart pointers</strong> automatically manage memory using RAII (Resource Acquisition Is Initialization).</p>

                    <h4>Smart Pointer Selection Guide</h4>
                    <table>
                        <tr><th>Type</th><th>Ownership</th><th>Copyable?</th><th>Use When</th></tr>
                        <tr><td><code>unique_ptr</code></td><td>Exclusive (single owner)</td><td>No (moveable)</td><td>Default choice, factory returns, class members</td></tr>
                        <tr><td><code>shared_ptr</code></td><td>Shared (ref counted)</td><td>Yes</td><td>Multiple owners, shared resources, caches</td></tr>
                        <tr><td><code>weak_ptr</code></td><td>Non-owning observer</td><td>Yes</td><td>Breaking cycles, caches, observers</td></tr>
                    </table>

                    <h4>unique_ptr - Your Default Choice</h4>
                    <div class="code-header">
                        <span>unique_ptr_detailed.cpp</span>
                        <span class="lang-badge">C++14</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;memory&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="keyword">class</span> <span class="type">Widget</span> {
<span class="keyword">public</span>:
    <span class="function">Widget</span>(<span class="keyword">int</span> id) : id_(id) { std::cout &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; id_ &lt;&lt; <span class="string">" created\n"</span>; }
    <span class="function">~Widget</span>() { std::cout &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; id_ &lt;&lt; <span class="string">" destroyed\n"</span>; }
    <span class="keyword">void</span> <span class="function">doWork</span>() { std::cout &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; id_ &lt;&lt; <span class="string">" working\n"</span>; }
<span class="keyword">private</span>:
    <span class="keyword">int</span> id_;
};

<span class="comment">// Factory function - returns unique_ptr</span>
std::unique_ptr&lt;Widget&gt; <span class="function">createWidget</span>(<span class="keyword">int</span> id) {
    <span class="keyword">return</span> std::make_unique&lt;Widget&gt;(id);  <span class="comment">// RVO - no move needed</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ CREATION ============</span>
    <span class="comment">// ALWAYS use make_unique (exception-safe, efficient)</span>
    <span class="keyword">auto</span> w1 = std::make_unique&lt;Widget&gt;(<span class="number">1</span>);

    <span class="comment">// DON'T do this (not exception-safe before C++17):</span>
    <span class="comment">// std::unique_ptr&lt;Widget&gt; bad(new Widget(2));</span>

    <span class="comment">// ============ ACCESS ============</span>
    w1->doWork();           <span class="comment">// Arrow operator</span>
    (*w1).doWork();         <span class="comment">// Dereference</span>
    Widget* raw = w1.get(); <span class="comment">// Get raw pointer (careful!)</span>

    <span class="comment">// ============ OWNERSHIP TRANSFER ============</span>
    <span class="comment">// unique_ptr cannot be copied - only moved</span>
    <span class="comment">// auto copy = w1;  // ERROR! Deleted copy constructor</span>

    <span class="keyword">auto</span> w2 = std::move(w1);  <span class="comment">// OK - w1 is now nullptr</span>
    <span class="keyword">if</span> (!w1) std::cout &lt;&lt; <span class="string">"w1 is empty after move\n"</span>;

    <span class="comment">// ============ IN CONTAINERS ============</span>
    std::vector&lt;std::unique_ptr&lt;Widget&gt;&gt; widgets;
    widgets.push_back(std::make_unique&lt;Widget&gt;(<span class="number">10</span>));
    widgets.push_back(createWidget(<span class="number">20</span>));

    <span class="comment">// ============ RELEASE AND RESET ============</span>
    Widget* released = w2.release();  <span class="comment">// Give up ownership (you must delete!)</span>
    <span class="keyword">delete</span> released;

    <span class="keyword">auto</span> w3 = std::make_unique&lt;Widget&gt;(<span class="number">3</span>);
    w3.reset();  <span class="comment">// Delete and set to nullptr</span>
    w3.reset(<span class="keyword">new</span> Widget(<span class="number">4</span>));  <span class="comment">// Delete old, take ownership of new</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}  <span class="comment">// All remaining unique_ptrs automatically cleaned up!</span>
</code></pre>

                    <h4>shared_ptr and weak_ptr - Breaking Cycles</h4>
                    <div class="code-header">
                        <span>shared_weak_ptr.cpp</span>
                        <span class="lang-badge">C++11</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;memory&gt;</span>

<span class="keyword">class</span> <span class="type">Node</span> {
<span class="keyword">public</span>:
    std::string name;
    std::shared_ptr&lt;Node&gt; next;     <span class="comment">// Owns next node</span>
    std::weak_ptr&lt;Node&gt; prev;       <span class="comment">// Doesn't own - prevents cycle!</span>

    <span class="function">Node</span>(<span class="keyword">const</span> std::string& n) : name(n) {
        std::cout &lt;&lt; <span class="string">"Node "</span> &lt;&lt; name &lt;&lt; <span class="string">" created\n"</span>;
    }
    <span class="function">~Node</span>() { std::cout &lt;&lt; <span class="string">"Node "</span> &lt;&lt; name &lt;&lt; <span class="string">" destroyed\n"</span>; }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// ============ SHARED_PTR BASICS ============</span>
    <span class="keyword">auto</span> node1 = std::make_shared&lt;Node&gt;(<span class="string">"First"</span>);
    std::cout &lt;&lt; <span class="string">"Ref count: "</span> &lt;&lt; node1.use_count() &lt;&lt; <span class="string">"\n"</span>;  <span class="comment">// 1</span>

    {
        <span class="keyword">auto</span> node1_copy = node1;  <span class="comment">// Shared ownership</span>
        std::cout &lt;&lt; <span class="string">"Ref count: "</span> &lt;&lt; node1.use_count() &lt;&lt; <span class="string">"\n"</span>;  <span class="comment">// 2</span>
    }  <span class="comment">// node1_copy destroyed, ref count back to 1</span>

    <span class="comment">// ============ BREAKING CYCLES WITH WEAK_PTR ============</span>
    <span class="keyword">auto</span> a = std::make_shared&lt;Node&gt;(<span class="string">"A"</span>);
    <span class="keyword">auto</span> b = std::make_shared&lt;Node&gt;(<span class="string">"B"</span>);

    a->next = b;      <span class="comment">// A owns B</span>
    b->prev = a;      <span class="comment">// B observes A (weak_ptr - no ownership)</span>

    <span class="comment">// Without weak_ptr, this would be a memory leak!</span>
    <span class="comment">// a->next = b; b->next = a; // BOTH ref counts stay at 1 forever</span>

    <span class="comment">// ============ USING WEAK_PTR ============</span>
    std::weak_ptr&lt;Node&gt; weakA = a;

    <span class="comment">// Must lock() to access - returns shared_ptr or nullptr</span>
    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weakA.lock()) {
        std::cout &lt;&lt; <span class="string">"Node still alive: "</span> &lt;&lt; locked->name &lt;&lt; <span class="string">"\n"</span>;
    }

    <span class="comment">// Check if object still exists</span>
    <span class="keyword">if</span> (!weakA.expired()) {
        std::cout &lt;&lt; <span class="string">"Object exists\n"</span>;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è Smart Pointer Pitfalls:</strong><br>
                        ‚Ä¢ <strong>Don't mix raw and smart:</strong> <code>delete smartPtr.get()</code> = double-free crash<br>
                        ‚Ä¢ <strong>shared_ptr cycles:</strong> Two objects pointing to each other = memory leak. Use weak_ptr!<br>
                        ‚Ä¢ <strong>Don't use make_shared with custom deleters</strong> - use constructor instead<br>
                        ‚Ä¢ <strong>Passing to functions:</strong> Pass by <code>const&</code> unless transferring ownership</div>
                    </div>

                    <div class="info">
                        <div><strong>üí° Best Practices:</strong><br>
                        ‚Ä¢ <strong>Default to unique_ptr</strong> - zero overhead, express single ownership<br>
                        ‚Ä¢ Use <code>make_unique</code> and <code>make_shared</code> - exception-safe and efficient<br>
                        ‚Ä¢ <strong>Rule of Zero:</strong> If all members are smart pointers, you don't need destructor/copy/move<br>
                        ‚Ä¢ Use <code>weak_ptr</code> for caches, observers, and breaking ownership cycles</div>
                    </div>
                </div>
            </div>

            <!-- Move Semantics -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üöÄ Move Semantics and Perfect Forwarding</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Pointers, references, copy constructors, value semantics<br>
                            <strong>üéØ Learning Objectives:</strong> Understand ownership transfer, optimize performance with moves<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 4-6 hours<br>
                            <strong>üîó Connects To:</strong> Smart pointers, Rule of Five, RAII, STL containers<br>
                            <strong>üîÑ Coming from Other Languages:</strong> This concept doesn't exist in GC languages - it's C++'s solution to efficient value transfer
                        </div>
                    </div>

                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a6"><label for="a6">Lvalues and rvalues</label></li>
                        <li><input type="checkbox" id="a7"><label for="a7">Move constructor and assignment</label></li>
                        <li><input type="checkbox" id="a8"><label for="a8">std::move and std::forward</label></li>
                        <li><input type="checkbox" id="a9"><label for="a9">Rule of Five</label></li>
                        <li><input type="checkbox" id="a10"><label for="a10">Perfect forwarding with universal references</label></li>
                    </ul>

                    <h4>üîÑ Why Move Semantics? (The GC Developer's Guide)</h4>
                    <p>If you're from Java, Python, or C#, you might wonder: <em>"Why do I need this? Assignment just works in my language!"</em></p>

                    <p>The answer lies in C++'s value semantics. Remember: in C++, assignment <strong>copies the entire object</strong>. For objects with dynamically allocated resources (strings, vectors, etc.), this means:</p>

                    <div class="code-header">
                        <span>The Problem Move Semantics Solves</span>
                        <span class="lang-badge">Conceptual</span>
                    </div>
<pre><code><span class="comment">// ============ IN JAVA/PYTHON ============</span>
<span class="comment">// List list1 = new ArrayList(1_000_000);  // 1M elements</span>
<span class="comment">// List list2 = list1;  // Just copies reference (8 bytes)</span>
<span class="comment">// Both point to SAME data - no copying of elements</span>

<span class="comment">// ============ IN C++ WITHOUT MOVE ============</span>
std::vector&lt;<span class="keyword">int</span>&gt; v1(<span class="number">1'000'000</span>);  <span class="comment">// 1M elements (~4MB)</span>
std::vector&lt;<span class="keyword">int</span>&gt; v2 = v1;        <span class="comment">// COPIES all 1M elements! (~4MB copy)</span>
<span class="comment">// v1 and v2 are INDEPENDENT - modifying v2 doesn't affect v1</span>

<span class="comment">// ============ THE PROBLEM ============</span>
std::vector&lt;<span class="keyword">int</span>&gt; <span class="function">createBigVector</span>() {
    std::vector&lt;<span class="keyword">int</span>&gt; result(<span class="number">1'000'000</span>);
    <span class="keyword">return</span> result;  <span class="comment">// Without move: COPY all 1M elements!</span>
}
<span class="keyword">auto</span> v = createBigVector();  <span class="comment">// Result is temporary, gets copied, then destroyed</span>
<span class="comment">// That's 8MB of unnecessary memory traffic!</span>

<span class="comment">// ============ WITH MOVE SEMANTICS ============</span>
<span class="comment">// Same code, but now the compiler uses MOVE instead of COPY</span>
<span class="comment">// Move: Transfer ownership of internal pointer</span>
<span class="comment">// result's pointer ‚Üí v's pointer (just 8 bytes!)</span>
<span class="comment">// result becomes empty shell, then is destroyed (nothing to free)</span>
</code></pre>

                    <table>
                        <tr><th>Scenario</th><th>Java/Python</th><th>C++ (Copy)</th><th>C++ (Move)</th></tr>
                        <tr><td>Return 1M-element vector</td><td>Return reference (free)</td><td>Copy 4MB</td><td>Move pointer (~8 bytes)</td></tr>
                        <tr><td>Push to container</td><td>Add reference (free)</td><td>Copy entire object</td><td>Move ownership</td></tr>
                        <tr><td>Memory safety</td><td>GC handles it</td><td>Both valid, independent</td><td>Source becomes empty</td></tr>
                    </table>

                    <div class="info">
                        <div><strong>üí° Key Insight:</strong> Move semantics gives C++ the <em>efficiency</em> of reference semantics (no copying) while maintaining <em>safety</em> of value semantics (no shared mutable state). It's the best of both worlds that GC languages can't achieve.</div>
                    </div>

                    <h4>Lvalues vs Rvalues: The Foundation</h4>
                    <div class="code-header">
                        <span>lvalue_rvalue.cpp</span>
                        <span class="lang-badge">C++11</span>
                    </div>
<pre><code><span class="comment">// LVALUE: Has a name, has an address, persists beyond expression</span>
<span class="keyword">int</span> x = <span class="number">42</span>;        <span class="comment">// x is an lvalue</span>
<span class="keyword">int</span>& ref = x;     <span class="comment">// OK: lvalue reference to lvalue</span>

<span class="comment">// RVALUE: Temporary, no name, dies at end of expression</span>
<span class="keyword">int</span>&& rref = <span class="number">42</span>;  <span class="comment">// OK: rvalue reference to rvalue (literal)</span>
<span class="keyword">int</span>&& rref2 = x + <span class="number">1</span>;  <span class="comment">// OK: x + 1 is a temporary rvalue</span>

<span class="comment">// WHY IT MATTERS:</span>
<span class="comment">// - Lvalues: We might use again ‚Üí must COPY (preserve original)</span>
<span class="comment">// - Rvalues: Temporary, dying anyway ‚Üí can MOVE (steal resources)</span>

std::vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};
std::vector&lt;<span class="keyword">int</span>&gt; v2 = v1;              <span class="comment">// v1 is lvalue ‚Üí COPY</span>
std::vector&lt;<span class="keyword">int</span>&gt; v3 = std::move(v1);   <span class="comment">// std::move makes it rvalue ‚Üí MOVE</span>
std::vector&lt;<span class="keyword">int</span>&gt; v4 = std::vector&lt;<span class="keyword">int</span>&gt;{<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};  <span class="comment">// Temporary ‚Üí MOVE</span>
</code></pre>

                    <h4>Implementing Move Semantics</h4>
                    <div class="code-header">
                        <span>move_semantics.cpp</span>
                        <span class="lang-badge">C++11</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;utility&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;cstring&gt;</span>

<span class="keyword">class</span> <span class="type">String</span> {
<span class="keyword">private</span>:
    <span class="keyword">char</span>* data;
    <span class="keyword">size_t</span> size;
<span class="keyword">public</span>:
    <span class="comment">// Constructor</span>
    <span class="function">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">""</span>) {
        size = strlen(str);
        data = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];
        strcpy(data, str);
        std::cout &lt;&lt; <span class="string">"Constructed"</span> &lt;&lt; std::endl;
    }

    <span class="comment">// Copy constructor</span>
    <span class="function">String</span>(<span class="keyword">const</span> String& other) {
        size = other.size;
        data = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];
        strcpy(data, other.data);
        std::cout &lt;&lt; <span class="string">"Copy constructed"</span> &lt;&lt; std::endl;
    }

    <span class="comment">// Move constructor</span>
    <span class="function">String</span>(String&& other) <span class="keyword">noexcept</span>
        : data(other.data), size(other.size) {
        other.data = <span class="keyword">nullptr</span>;
        other.size = <span class="number">0</span>;
        std::cout &lt;&lt; <span class="string">"Move constructed"</span> &lt;&lt; std::endl;
    }

    <span class="comment">// Copy assignment</span>
    String& <span class="keyword">operator</span>=(<span class="keyword">const</span> String& other) {
        <span class="keyword">if</span> (<span class="keyword">this</span> != &other) {
            <span class="keyword">delete</span>[] data;
            size = other.size;
            data = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];
            strcpy(data, other.data);
        }
        std::cout &lt;&lt; <span class="string">"Copy assigned"</span> &lt;&lt; std::endl;
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    <span class="comment">// Move assignment</span>
    String& <span class="keyword">operator</span>=(String&& other) <span class="keyword">noexcept</span> {
        <span class="keyword">if</span> (<span class="keyword">this</span> != &other) {
            <span class="keyword">delete</span>[] data;
            data = other.data;
            size = other.size;
            other.data = <span class="keyword">nullptr</span>;
            other.size = <span class="number">0</span>;
        }
        std::cout &lt;&lt; <span class="string">"Move assigned"</span> &lt;&lt; std::endl;
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    <span class="function">~String</span>() { <span class="keyword">delete</span>[] data; }
};

<span class="comment">// Perfect forwarding</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">void</span> <span class="function">wrapper</span>(T&& arg) {
    process(std::forward&lt;T&gt;(arg));  <span class="comment">// Preserves value category</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    String s1(<span class="string">"Hello"</span>);
    String s2 = s1;                    <span class="comment">// Copy</span>
    String s3 = std::move(s1);         <span class="comment">// Move (s1 is now empty)</span>
    String s4 = String(<span class="string">"Temporary"</span>);  <span class="comment">// Move from temporary</span>

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <h4>‚ö†Ô∏è Common Pitfalls for GC Language Developers</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üî¥ Using moved-from object</h5>
                            <p>After <code>std::move(x)</code>, x is in "valid but unspecified" state. Don't use it except to reassign or destroy!</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ std::move doesn't move</h5>
                            <p><code>std::move</code> is just a cast to rvalue reference. The actual move happens in the move constructor/assignment.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Forgetting noexcept</h5>
                            <p>Move operations should be <code>noexcept</code>. STL containers only use move if it's noexcept!</p>
                        </div>
                        <div class="topic-card">
                            <h5>üî¥ Moving const objects</h5>
                            <p><code>std::move(const_obj)</code> doesn't move - it falls back to copy. Can't steal from const!</p>
                        </div>
                    </div>

                    <div class="info">
                        <div><strong>üí° Best Practice:</strong> Let the compiler do it! Return by value, use standard containers, and the compiler will use moves automatically. Only write explicit move operations for classes managing raw resources.</div>
                    </div>
                </div>
            </div>

            <!-- Lambdas -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Œª Lambda Expressions</span>
                </div>
                <div class="collapsible-content">
                    <!-- Learning Context Box -->
                    <div class="note" style="margin-bottom: 20px;">
                        <div>
                            <strong>üìã Prerequisites:</strong> Functions, references, basic templates<br>
                            <strong>üéØ Learning Objectives:</strong> Create inline function objects, understand capture semantics<br>
                            <strong>‚è±Ô∏è Estimated Time:</strong> 2-3 hours<br>
                            <strong>üîó Connects To:</strong> STL algorithms, function objects, functional programming<br>
                            <strong>üîÑ Coming from Other Languages:</strong> Similar to Java lambdas/Python lambdas/JS arrow functions, but with explicit capture control
                        </div>
                    </div>

                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a11"><label for="a11">Lambda syntax and captures</label></li>
                        <li><input type="checkbox" id="a12"><label for="a12">Capture by value vs reference</label></li>
                        <li><input type="checkbox" id="a13"><label for="a13">Generic lambdas (C++14)</label></li>
                        <li><input type="checkbox" id="a14"><label for="a14">Lambda with init captures (C++14)</label></li>
                        <li><input type="checkbox" id="a15"><label for="a15">constexpr lambdas (C++17)</label></li>
                    </ul>

                    <h4>üîÑ C++ Lambdas vs Other Languages</h4>
                    <p>C++ lambdas are similar to closures in other languages, but with one major difference: <strong>explicit capture control</strong>. While Java, Python, and JavaScript automatically capture variables from the enclosing scope, C++ requires you to specify what and how to capture.</p>

                    <table>
                        <tr><th>Aspect</th><th>Java</th><th>Python</th><th>JavaScript</th><th>C++</th></tr>
                        <tr><td><strong>Syntax</strong></td><td><code>(x) -&gt; x * 2</code></td><td><code>lambda x: x * 2</code></td><td><code>(x) =&gt; x * 2</code></td><td><code>[](int x) { return x * 2; }</code></td></tr>
                        <tr><td><strong>Capture</strong></td><td>Auto (final only)</td><td>Auto (by reference)</td><td>Auto (by reference)</td><td><strong>Explicit: <code>[=]</code>, <code>[&amp;]</code>, <code>[x]</code></strong></td></tr>
                        <tr><td><strong>Multi-statement</strong></td><td>Yes with <code>{}</code></td><td>No (single expression)</td><td>Yes with <code>{}</code></td><td>Yes</td></tr>
                        <tr><td><strong>Mutable capture</strong></td><td>No (effectively final)</td><td>Yes (gotcha!)</td><td>Yes</td><td>Yes with <code>mutable</code></td></tr>
                        <tr><td><strong>Generic/auto</strong></td><td>No</td><td>Dynamic typing</td><td>Dynamic typing</td><td>Yes (C++14 <code>auto</code>)</td></tr>
                    </table>

                    <div class="warning">
                        <div><strong>‚ö†Ô∏è The Capture Gotcha:</strong> In Python/JS, lambdas capture by reference automatically, leading to the infamous "loop variable capture" bug. C++'s explicit captures prevent this - you must choose: <code>[=]</code> (copy) or <code>[&amp;]</code> (reference).</div>
                    </div>

                    <h4>Capture Syntax Comparison</h4>
                    <div class="code-header">
                        <span>Lambda Capture Comparison</span>
                        <span class="lang-badge">Cross-Language</span>
                    </div>
<pre><code><span class="comment">// ============ JAVASCRIPT CLOSURE BUG ============</span>
<span class="comment">// const funcs = [];</span>
<span class="comment">// for (var i = 0; i &lt; 3; i++) {</span>
<span class="comment">//     funcs.push(() =&gt; console.log(i));</span>
<span class="comment">// }</span>
<span class="comment">// funcs[0](); funcs[1](); funcs[2]();  // Prints: 3, 3, 3 (bug!)</span>

<span class="comment">// ============ PYTHON CLOSURE BUG ============</span>
<span class="comment">// funcs = [lambda: i for i in range(3)]</span>
<span class="comment">// print([f() for f in funcs])  # [2, 2, 2] (bug!)</span>

<span class="comment">// ============ C++ - EXPLICIT CONTROL ============</span>
std::vector&lt;std::function&lt;<span class="keyword">int</span>()&gt;&gt; funcs;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
    funcs.push_back([i]() { <span class="keyword">return</span> i; });  <span class="comment">// [i] = capture by value</span>
}
<span class="comment">// funcs[0](), funcs[1](), funcs[2]() returns: 0, 1, 2 (correct!)</span>

<span class="comment">// If you WANT the JS/Python behavior (rare):</span>
<span class="keyword">int</span> j = <span class="number">0</span>;
<span class="keyword">auto</span> refCapture = [&j]() { <span class="keyword">return</span> j; };  <span class="comment">// [&amp;j] = capture by reference</span>
j = <span class="number">42</span>;
<span class="comment">// refCapture() returns 42 (captures current value of j)</span>
</code></pre>

                    <h4>C++ Lambda Capture Options</h4>
                    <table>
                        <tr><th>Capture</th><th>Meaning</th><th>Use When</th></tr>
                        <tr><td><code>[]</code></td><td>Capture nothing</td><td>Pure functions, no external state</td></tr>
                        <tr><td><code>[=]</code></td><td>All by value (copy)</td><td>Lambda outlives scope, need snapshot</td></tr>
                        <tr><td><code>[&amp;]</code></td><td>All by reference</td><td>Modifying external state, lambda is short-lived</td></tr>
                        <tr><td><code>[x]</code></td><td>Specific var by value</td><td>Explicit control (recommended)</td></tr>
                        <tr><td><code>[&amp;x]</code></td><td>Specific var by reference</td><td>Need to modify specific variable</td></tr>
                        <tr><td><code>[=, &amp;x]</code></td><td>All by value, x by reference</td><td>Mixed needs</td></tr>
                        <tr><td><code>[x = std::move(y)]</code></td><td>Init capture (C++14)</td><td>Move-only types, renamed captures</td></tr>
                    </table>

                    <div class="code-header">
                        <span>lambdas.cpp</span>
                        <span class="lang-badge">C++14</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;algorithm&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;functional&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Basic lambda</span>
    <span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) { <span class="keyword">return</span> a + b; };
    std::cout &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 7</span>

    <span class="comment">// Capture by value [=] and reference [&]</span>
    <span class="keyword">int</span> multiplier = <span class="number">10</span>;
    <span class="keyword">auto</span> byValue = [=](<span class="keyword">int</span> x) { <span class="keyword">return</span> x * multiplier; };
    <span class="keyword">auto</span> byRef = [&](<span class="keyword">int</span> x) { multiplier++; <span class="keyword">return</span> x * multiplier; };

    <span class="comment">// Mixed capture</span>
    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;
    <span class="keyword">auto</span> mixed = [a, &b]() { b = a + b; };  <span class="comment">// a by value, b by reference</span>

    <span class="comment">// Generic lambda (C++14)</span>
    <span class="keyword">auto</span> print = [](<span class="keyword">const auto</span>& x) { std::cout &lt;&lt; x &lt;&lt; std::endl; };
    print(<span class="number">42</span>);
    print(<span class="string">"Hello"</span>);

    <span class="comment">// Init capture / move capture (C++14)</span>
    std::unique_ptr&lt;<span class="keyword">int</span>&gt; ptr = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);
    <span class="keyword">auto</span> moveLambda = [p = std::move(ptr)]() {
        std::cout &lt;&lt; *p &lt;&lt; std::endl;
    };

    <span class="comment">// Lambda with mutable (allows modifying captured by-value vars)</span>
    <span class="keyword">int</span> counter = <span class="number">0</span>;
    <span class="keyword">auto</span> increment = [counter]() <span class="keyword">mutable</span> { <span class="keyword">return</span> ++counter; };

    <span class="comment">// Using lambdas with STL algorithms</span>
    std::vector&lt;<span class="keyword">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    std::for_each(nums.begin(), nums.end(), [](<span class="keyword">int</span>& n) { n *= <span class="number">2</span>; });

    <span class="keyword">auto</span> it = std::find_if(nums.begin(), nums.end(),
                           [](<span class="keyword">int</span> n) { <span class="keyword">return</span> n > <span class="number">5</span>; });

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Multithreading -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üîÑ Multithreading and Concurrency</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a16"><label for="a16">std::thread basics</label></li>
                        <li><input type="checkbox" id="a17"><label for="a17">Mutexes and locks</label></li>
                        <li><input type="checkbox" id="a18"><label for="a18">Condition variables</label></li>
                        <li><input type="checkbox" id="a19"><label for="a19">std::async and futures</label></li>
                        <li><input type="checkbox" id="a20"><label for="a20">Atomic operations</label></li>
                        <li><input type="checkbox" id="a21"><label for="a21">Thread pools</label></li>
                    </ul>

                    <div class="code-header">
                        <span>multithreading.cpp</span>
                        <span class="lang-badge">C++11</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;thread&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;mutex&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;future&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;atomic&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>

std::mutex mtx;
std::atomic&lt;<span class="keyword">int</span>&gt; atomicCounter{<span class="number">0</span>};

<span class="keyword">void</span> <span class="function">safeIncrement</span>(<span class="keyword">int</span>& counter) {
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  <span class="comment">// RAII lock</span>
    ++counter;
}

<span class="keyword">int</span> <span class="function">compute</span>(<span class="keyword">int</span> x) {
    std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">100</span>));
    <span class="keyword">return</span> x * x;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Basic thread</span>
    std::thread t1([]() {
        std::cout &lt;&lt; <span class="string">"Hello from thread!"</span> &lt;&lt; std::endl;
    });
    t1.join();  <span class="comment">// Wait for thread to finish</span>

    <span class="comment">// Thread with arguments</span>
    <span class="keyword">int</span> counter = <span class="number">0</span>;
    std::vector&lt;std::thread&gt; threads;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {
        threads.emplace_back(safeIncrement, std::ref(counter));
    }
    <span class="keyword">for</span> (<span class="keyword">auto</span>& t : threads) t.join();
    std::cout &lt;&lt; <span class="string">"Counter: "</span> &lt;&lt; counter &lt;&lt; std::endl;

    <span class="comment">// Atomic operations (lock-free)</span>
    std::vector&lt;std::thread&gt; atomicThreads;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {
        atomicThreads.emplace_back([]() { atomicCounter++; });
    }
    <span class="keyword">for</span> (<span class="keyword">auto</span>& t : atomicThreads) t.join();

    <span class="comment">// std::async - higher-level abstraction</span>
    std::future&lt;<span class="keyword">int</span>&gt; result = std::async(std::launch::async, compute, <span class="number">5</span>);
    std::cout &lt;&lt; <span class="string">"Doing other work..."</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; result.get() &lt;&lt; std::endl;  <span class="comment">// Blocks until ready</span>

    <span class="comment">// Multiple futures</span>
    std::vector&lt;std::future&lt;<span class="keyword">int</span>&gt;&gt; futures;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) {
        futures.push_back(std::async(std::launch::async, compute, i));
    }
    <span class="keyword">for</span> (<span class="keyword">auto</span>& f : futures) {
        std::cout &lt;&lt; f.get() &lt;&lt; <span class="string">" "</span>;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

                    <div class="video-section">
                        <h4>Recommended Concurrency Videos</h4>
                        <div class="video-grid">
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>C++ Threading</h5>
                                    <p class="channel">The Cherno</p>
                                    <a href="https://www.youtube.com/watch?v=wXBcwHwIt_I" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modern C++ Features -->
            <div class="collapsible" id="modern-cpp">
                <div class="collapsible-header">
                    <span>‚ú® Modern C++ Features (C++17/20/23)</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a22"><label for="a22">Structured bindings (C++17)</label></li>
                        <li><input type="checkbox" id="a23"><label for="a23">std::optional, std::variant, std::any (C++17)</label></li>
                        <li><input type="checkbox" id="a24"><label for="a24">if constexpr (C++17)</label></li>
                        <li><input type="checkbox" id="a25"><label for="a25">Concepts (C++20)</label></li>
                        <li><input type="checkbox" id="a26"><label for="a26">Ranges library (C++20)</label></li>
                        <li><input type="checkbox" id="a27"><label for="a27">Coroutines (C++20)</label></li>
                        <li><input type="checkbox" id="a28"><label for="a28">Modules (C++20)</label></li>
                        <li><input type="checkbox" id="a29"><label for="a29">std::expected (C++23)</label></li>
                    </ul>

                    <div class="code-header">
                        <span>modern_cpp.cpp</span>
                        <span class="lang-badge">C++20</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;optional&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;variant&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;ranges&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;concepts&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;map&gt;</span>

<span class="comment">// Concepts (C++20) - type constraints</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">concept</span> Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;

<span class="keyword">template</span>&lt;Numeric T&gt;
T <span class="function">add</span>(T a, T b) {
    <span class="keyword">return</span> a + b;
}

<span class="comment">// std::optional - nullable value</span>
std::optional&lt;<span class="keyword">int</span>&gt; <span class="function">findValue</span>(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;& vec, <span class="keyword">int</span> target) {
    <span class="keyword">for</span> (<span class="keyword">int</span> v : vec) {
        <span class="keyword">if</span> (v == target) <span class="keyword">return</span> v;
    }
    <span class="keyword">return</span> std::nullopt;
}

<span class="comment">// if constexpr - compile-time branching</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">auto</span> <span class="function">getValue</span>(T t) {
    <span class="keyword">if constexpr</span> (std::is_pointer_v&lt;T&gt;) {
        <span class="keyword">return</span> *t;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> t;
    }
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Structured bindings (C++17)</span>
    std::map&lt;std::string, <span class="keyword">int</span>&gt; scores = {{<span class="string">"Alice"</span>, <span class="number">95</span>}, {<span class="string">"Bob"</span>, <span class="number">87</span>}};
    <span class="keyword">for</span> (<span class="keyword">const auto</span>& [name, score] : scores) {
        std::cout &lt;&lt; name &lt;&lt; <span class="string">": "</span> &lt;&lt; score &lt;&lt; std::endl;
    }

    <span class="comment">// std::optional</span>
    std::vector&lt;<span class="keyword">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    <span class="keyword">if</span> (<span class="keyword">auto</span> result = findValue(nums, <span class="number">3</span>)) {
        std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *result &lt;&lt; std::endl;
    }

    <span class="comment">// std::variant - type-safe union</span>
    std::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, std::string&gt; value = <span class="number">42</span>;
    value = <span class="string">"Hello"</span>;
    std::cout &lt;&lt; std::get&lt;std::string&gt;(value) &lt;&lt; std::endl;

    <span class="comment">// Ranges (C++20)</span>
    std::vector&lt;<span class="keyword">int</span>&gt; numbers = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};
    <span class="keyword">auto</span> evenSquares = numbers
        | std::views::filter([](<span class="keyword">int</span> n) { <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; })
        | std::views::transform([](<span class="keyword">int</span> n) { <span class="keyword">return</span> n * n; });

    <span class="keyword">for</span> (<span class="keyword">int</span> n : evenSquares) {
        std::cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 4 16 36 64 100</span>
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>

            <!-- Design Patterns -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üèõÔ∏è Design Patterns in C++</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="a30"><label for="a30">Singleton Pattern</label></li>
                        <li><input type="checkbox" id="a31"><label for="a31">Factory Pattern</label></li>
                        <li><input type="checkbox" id="a32"><label for="a32">Observer Pattern</label></li>
                        <li><input type="checkbox" id="a33"><label for="a33">Strategy Pattern</label></li>
                        <li><input type="checkbox" id="a34"><label for="a34">CRTP (Curiously Recurring Template Pattern)</label></li>
                        <li><input type="checkbox" id="a35"><label for="a35">Pimpl Idiom</label></li>
                    </ul>

                    <div class="code-header">
                        <span>design_patterns.cpp</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;memory&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;functional&gt;</span>

<span class="comment">// ============ SINGLETON ============</span>
<span class="keyword">class</span> <span class="type">Singleton</span> {
<span class="keyword">private</span>:
    <span class="function">Singleton</span>() = <span class="keyword">default</span>;
<span class="keyword">public</span>:
    Singleton(<span class="keyword">const</span> Singleton&) = <span class="keyword">delete</span>;
    Singleton& <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&) = <span class="keyword">delete</span>;

    <span class="keyword">static</span> Singleton& <span class="function">getInstance</span>() {
        <span class="keyword">static</span> Singleton instance;  <span class="comment">// Thread-safe in C++11+</span>
        <span class="keyword">return</span> instance;
    }
    <span class="keyword">void</span> <span class="function">doSomething</span>() { std::cout &lt;&lt; <span class="string">"Singleton action"</span> &lt;&lt; std::endl; }
};

<span class="comment">// ============ FACTORY ============</span>
<span class="keyword">class</span> <span class="type">Product</span> {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">operation</span>() = <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="function">~Product</span>() = <span class="keyword">default</span>;
};

<span class="keyword">class</span> <span class="type">ConcreteProductA</span> : <span class="keyword">public</span> Product {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">operation</span>() <span class="keyword">override</span> { std::cout &lt;&lt; <span class="string">"Product A"</span> &lt;&lt; std::endl; }
};

<span class="keyword">class</span> <span class="type">ConcreteProductB</span> : <span class="keyword">public</span> Product {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">operation</span>() <span class="keyword">override</span> { std::cout &lt;&lt; <span class="string">"Product B"</span> &lt;&lt; std::endl; }
};

<span class="keyword">class</span> <span class="type">Factory</span> {
<span class="keyword">public</span>:
    <span class="keyword">static</span> std::unique_ptr&lt;Product&gt; <span class="function">create</span>(<span class="keyword">const</span> std::string& type) {
        <span class="keyword">if</span> (type == <span class="string">"A"</span>) <span class="keyword">return</span> std::make_unique&lt;ConcreteProductA&gt;();
        <span class="keyword">if</span> (type == <span class="string">"B"</span>) <span class="keyword">return</span> std::make_unique&lt;ConcreteProductB&gt;();
        <span class="keyword">return</span> <span class="keyword">nullptr</span>;
    }
};

<span class="comment">// ============ OBSERVER ============</span>
<span class="keyword">class</span> <span class="type">Subject</span> {
    std::vector&lt;std::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;&gt; observers;
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">subscribe</span>(std::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; observer) {
        observers.push_back(observer);
    }
    <span class="keyword">void</span> <span class="function">notify</span>(<span class="keyword">int</span> value) {
        <span class="keyword">for</span> (<span class="keyword">auto</span>& obs : observers) obs(value);
    }
};

<span class="comment">// ============ CRTP ============</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;
<span class="keyword">class</span> <span class="type">Base</span> {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">interface</span>() {
        <span class="keyword">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)->implementation();
    }
};

<span class="keyword">class</span> <span class="type">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">implementation</span>() { std::cout &lt;&lt; <span class="string">"CRTP implementation"</span> &lt;&lt; std::endl; }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Singleton</span>
    Singleton::getInstance().doSomething();

    <span class="comment">// Factory</span>
    <span class="keyword">auto</span> product = Factory::create(<span class="string">"A"</span>);
    product->operation();

    <span class="comment">// Observer</span>
    Subject subject;
    subject.subscribe([](<span class="keyword">int</span> v) { std::cout &lt;&lt; <span class="string">"Observer 1: "</span> &lt;&lt; v &lt;&lt; std::endl; });
    subject.notify(<span class="number">42</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
                </div>
            </div>
        </section>

        <!-- ==================== INDUSTRY SECTION ==================== -->
        <section id="industry">
            <h2>üè≠ Industry Applications <span class="badge badge-expert">Expert</span></h2>

            <div class="info">
                <div>Learn professional tools and practices used in real-world C++ development environments.</div>
            </div>

            <!-- Build Systems -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üî® Build Systems (CMake)</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="ind1"><label for="ind1">CMake basics and CMakeLists.txt</label></li>
                        <li><input type="checkbox" id="ind2"><label for="ind2">Targets and dependencies</label></li>
                        <li><input type="checkbox" id="ind3"><label for="ind3">Finding and linking libraries</label></li>
                        <li><input type="checkbox" id="ind4"><label for="ind4">Modern CMake practices</label></li>
                    </ul>

                    <div class="code-header">
                        <span>CMakeLists.txt</span>
                        <span class="lang-badge">CMake</span>
                    </div>
<pre><code><span class="comment"># Minimum CMake version</span>
<span class="function">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)

<span class="comment"># Project definition</span>
<span class="function">project</span>(MyProject
    VERSION <span class="number">1.0.0</span>
    DESCRIPTION <span class="string">"A modern C++ project"</span>
    LANGUAGES CXX
)

<span class="comment"># C++ Standard</span>
<span class="function">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)
<span class="function">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)

<span class="comment"># Add executable</span>
<span class="function">add_executable</span>(myapp
    src/main.cpp
    src/utils.cpp
)

<span class="comment"># Include directories</span>
<span class="function">target_include_directories</span>(myapp PRIVATE
    ${PROJECT_SOURCE_DIR}/include
)

<span class="comment"># Find external library</span>
<span class="function">find_package</span>(Threads REQUIRED)

<span class="comment"># Link libraries</span>
<span class="function">target_link_libraries</span>(myapp PRIVATE
    Threads::Threads
)

<span class="comment"># Compiler warnings</span>
<span class="function">target_compile_options</span>(myapp PRIVATE
    $&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:-Wall -Wextra -Wpedantic&gt;
    $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/W4&gt;
)

<span class="comment"># Enable testing</span>
<span class="function">enable_testing</span>()
<span class="function">add_subdirectory</span>(tests)
</code></pre>

                    <h4>Project Structure</h4>
<pre><code>MyProject/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ myproject/
‚îÇ       ‚îú‚îÄ‚îÄ utils.hpp
‚îÇ       ‚îî‚îÄ‚îÄ config.hpp
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp
‚îÇ   ‚îî‚îÄ‚îÄ utils.cpp
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
‚îÇ   ‚îî‚îÄ‚îÄ test_utils.cpp
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ build/              <span class="comment"># Generated, gitignored</span>
‚îî‚îÄ‚îÄ README.md
</code></pre>
                </div>
            </div>

            <!-- Testing -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üß™ Testing Frameworks</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="ind5"><label for="ind5">Google Test basics</label></li>
                        <li><input type="checkbox" id="ind6"><label for="ind6">Test fixtures</label></li>
                        <li><input type="checkbox" id="ind7"><label for="ind7">Mocking with Google Mock</label></li>
                        <li><input type="checkbox" id="ind8"><label for="ind8">Catch2 framework</label></li>
                    </ul>

                    <div class="code-header">
                        <span>test_calculator.cpp (Google Test)</span>
                        <span class="lang-badge">C++</span>
                    </div>
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;gtest/gtest.h&gt;</span>
<span class="preprocessor">#include</span> <span class="string">"calculator.hpp"</span>

<span class="comment">// Simple test</span>
<span class="function">TEST</span>(CalculatorTest, AddPositiveNumbers) {
    Calculator calc;
    EXPECT_EQ(calc.add(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>);
}

<span class="function">TEST</span>(CalculatorTest, DivisionByZero) {
    Calculator calc;
    EXPECT_THROW(calc.divide(<span class="number">10</span>, <span class="number">0</span>), std::invalid_argument);
}

<span class="comment">// Test fixture for setup/teardown</span>
<span class="keyword">class</span> <span class="type">DatabaseTest</span> : <span class="keyword">public</span> ::testing::Test {
<span class="keyword">protected</span>:
    <span class="keyword">void</span> <span class="function">SetUp</span>() <span class="keyword">override</span> {
        db = std::make_unique&lt;Database&gt;();
        db->connect(<span class="string">"test_db"</span>);
    }

    <span class="keyword">void</span> <span class="function">TearDown</span>() <span class="keyword">override</span> {
        db->disconnect();
    }

    std::unique_ptr&lt;Database&gt; db;
};

<span class="function">TEST_F</span>(DatabaseTest, InsertRecord) {
    EXPECT_TRUE(db->insert(<span class="string">"key"</span>, <span class="string">"value"</span>));
    EXPECT_EQ(db->get(<span class="string">"key"</span>), <span class="string">"value"</span>);
}

<span class="comment">// Parameterized tests</span>
<span class="keyword">class</span> <span class="type">FibonacciTest</span> : <span class="keyword">public</span> ::testing::TestWithParam&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; {};

<span class="function">TEST_P</span>(FibonacciTest, Values) {
    <span class="keyword">auto</span> [input, expected] = GetParam();
    EXPECT_EQ(fibonacci(input), expected);
}

<span class="function">INSTANTIATE_TEST_SUITE_P</span>(FibTests, FibonacciTest,
    ::testing::Values(
        std::make_pair(<span class="number">0</span>, <span class="number">0</span>),
        std::make_pair(<span class="number">1</span>, <span class="number">1</span>),
        std::make_pair(<span class="number">10</span>, <span class="number">55</span>)
    )
);

<span class="keyword">int</span> <span class="function">main</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    <span class="keyword">return</span> RUN_ALL_TESTS();
}
</code></pre>
                </div>
            </div>

            <!-- Debugging -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üîç Debugging and Profiling</span>
                </div>
                <div class="collapsible-content">
                    <ul class="checklist" data-level="advanced">
                        <li><input type="checkbox" id="ind9"><label for="ind9">GDB/LLDB basics</label></li>
                        <li><input type="checkbox" id="ind10"><label for="ind10">Valgrind for memory analysis</label></li>
                        <li><input type="checkbox" id="ind11"><label for="ind11">AddressSanitizer and other sanitizers</label></li>
                        <li><input type="checkbox" id="ind12"><label for="ind12">Performance profiling</label></li>
                    </ul>

                    <h4>Essential GDB Commands</h4>
                    <table>
                        <tr><th>Command</th><th>Description</th></tr>
                        <tr><td><code>gdb ./program</code></td><td>Start debugging</td></tr>
                        <tr><td><code>b main</code></td><td>Set breakpoint at main</td></tr>
                        <tr><td><code>r</code></td><td>Run program</td></tr>
                        <tr><td><code>n</code></td><td>Next line (step over)</td></tr>
                        <tr><td><code>s</code></td><td>Step into function</td></tr>
                        <tr><td><code>p variable</code></td><td>Print variable value</td></tr>
                        <tr><td><code>bt</code></td><td>Backtrace (call stack)</td></tr>
                        <tr><td><code>watch var</code></td><td>Watch variable changes</td></tr>
                    </table>

                    <h4>Compile with Debug Info and Sanitizers</h4>
<pre><code><span class="comment"># Debug build</span>
g++ -g -O0 -o debug_program main.cpp

<span class="comment"># AddressSanitizer (memory errors)</span>
g++ -fsanitize=address -g -o asan_program main.cpp

<span class="comment"># UndefinedBehaviorSanitizer</span>
g++ -fsanitize=undefined -g -o ubsan_program main.cpp

<span class="comment"># ThreadSanitizer (data races)</span>
g++ -fsanitize=thread -g -o tsan_program main.cpp

<span class="comment"># Valgrind</span>
valgrind --leak-check=full ./program
</code></pre>
                </div>
            </div>

            <!-- Best Practices -->
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>üìã Best Practices and Guidelines</span>
                </div>
                <div class="collapsible-content">
                    <h4>C++ Core Guidelines Summary</h4>
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h5>üéØ Resource Management</h5>
                            <p>Use RAII. Prefer smart pointers over raw pointers. Never use <code>new</code>/<code>delete</code> directly.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üîí Type Safety</h5>
                            <p>Use <code>auto</code> to avoid redundant type names. Prefer <code>enum class</code> over plain <code>enum</code>.</p>
                        </div>
                        <div class="topic-card">
                            <h5>‚ö° Performance</h5>
                            <p>Pass by <code>const&</code> for read-only. Use move semantics. Avoid unnecessary copies.</p>
                        </div>
                        <div class="topic-card">
                            <h5>üßπ Clean Code</h5>
                            <p>Follow consistent naming. Keep functions small. Use meaningful names.</p>
                        </div>
                    </div>

                    <div class="video-section">
                        <h4>Recommended Industry Videos</h4>
                        <div class="video-grid">
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>CppCon Back to Basics</h5>
                                    <p class="channel">CppCon</p>
                                    <a href="https://www.youtube.com/watch?v=XkDEzfpdcSg" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                            <div class="video-card">
                                <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                                <div class="video-info">
                                    <h5>Modern CMake Tutorial</h5>
                                    <p class="channel">Code Tech</p>
                                    <a href="https://www.youtube.com/watch?v=nlKcXPUJGwA" target="_blank" class="video-link">‚ñ∂ Watch on YouTube</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ==================== INTERVIEW SECTION ==================== -->
        <section id="interview">
            <h2>üíº Expert Interview Preparation <span class="badge badge-expert">50+ Questions</span></h2>

            <div class="note">
                <div>Comprehensive collection of C++ interview questions from beginner to expert level. Click on any question to reveal the detailed answer.</div>
            </div>

            <h3>üü¢ Fundamentals (Beginner)</h3>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q1</span> What is the difference between C and C++?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>Key Differences:</strong></p>
                        <ul>
                            <li><strong>Paradigm:</strong> C is procedural; C++ supports OOP, generic, and functional programming</li>
                            <li><strong>Memory:</strong> C uses malloc/free; C++ uses new/delete and smart pointers</li>
                            <li><strong>Type Safety:</strong> C++ has stronger type checking and type-safe casts</li>
                            <li><strong>Features:</strong> C++ adds classes, templates, exceptions, namespaces, STL</li>
                            <li><strong>I/O:</strong> C uses printf/scanf; C++ uses iostream (cout/cin)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q2</span> Explain the difference between struct and class in C++.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p>The only difference is the <strong>default access specifier</strong>:</p>
                        <ul>
                            <li><code>struct</code>: Members are <code>public</code> by default</li>
                            <li><code>class</code>: Members are <code>private</code> by default</li>
                        </ul>
                        <p>Same applies to inheritance - struct defaults to public inheritance, class to private.</p>
<pre><code><span class="keyword">struct</span> S { <span class="keyword">int</span> x; };      <span class="comment">// x is public</span>
<span class="keyword">class</span> C { <span class="keyword">int</span> x; };       <span class="comment">// x is private</span></code></pre>
                        <p><strong>Best Practice:</strong> Use struct for plain data structures (POD), class for objects with behavior.</p>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q3</span> What is the difference between stack and heap memory?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>Stack</th><th>Heap</th></tr>
                            <tr><td>Automatic allocation/deallocation</td><td>Manual management (new/delete)</td></tr>
                            <tr><td>Fast access (LIFO)</td><td>Slower access</td></tr>
                            <tr><td>Limited size (~1-8 MB)</td><td>Large size (RAM limited)</td></tr>
                            <tr><td>Local variables, function calls</td><td>Dynamic objects</td></tr>
                            <tr><td>Thread-local</td><td>Shared across threads</td></tr>
                        </table>
<pre><code><span class="keyword">void</span> <span class="function">example</span>() {
    <span class="keyword">int</span> stackVar = <span class="number">10</span>;           <span class="comment">// Stack allocation</span>
    <span class="keyword">int</span>* heapVar = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>);   <span class="comment">// Heap allocation</span>
    <span class="keyword">delete</span> heapVar;                <span class="comment">// Must free heap memory</span>
}   <span class="comment">// stackVar automatically destroyed</span></code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q4</span> What are pointers and references? How do they differ?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>Pointers</th><th>References</th></tr>
                            <tr><td>Can be null</td><td>Cannot be null (must be initialized)</td></tr>
                            <tr><td>Can be reassigned</td><td>Cannot be rebound after initialization</td></tr>
                            <tr><td>Use * and & operators</td><td>Automatic dereferencing</td></tr>
                            <tr><td>Can have pointer arithmetic</td><td>No arithmetic</td></tr>
                            <tr><td>sizeof gives pointer size</td><td>sizeof gives referenced object size</td></tr>
                        </table>
<pre><code><span class="keyword">int</span> x = <span class="number">10</span>;
<span class="keyword">int</span>* ptr = &x;     <span class="comment">// Pointer to x</span>
<span class="keyword">int</span>& ref = x;     <span class="comment">// Reference to x</span>
*ptr = <span class="number">20</span>;         <span class="comment">// x = 20</span>
ref = <span class="number">30</span>;          <span class="comment">// x = 30 (no dereferencing needed)</span></code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q5</span> Explain const correctness in C++.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
<pre><code><span class="comment">// Const variable - cannot be modified</span>
<span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">10</span>;

<span class="comment">// Pointer to const - data cannot be modified via pointer</span>
<span class="keyword">const</span> <span class="keyword">int</span>* p1 = &x;    <span class="comment">// or: int const* p1</span>

<span class="comment">// Const pointer - pointer cannot be reassigned</span>
<span class="keyword">int</span>* <span class="keyword">const</span> p2 = &y;

<span class="comment">// Const pointer to const - neither can be modified</span>
<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &x;

<span class="comment">// Const member function - doesn't modify object state</span>
<span class="keyword">class</span> MyClass {
    <span class="keyword">int</span> <span class="function">getValue</span>() <span class="keyword">const</span> { <span class="keyword">return</span> value; }  <span class="comment">// Promise not to modify</span>
};</code></pre>
                        <p><strong>Best Practice:</strong> Use const by default. It enables compiler optimizations and prevents bugs.</p>
                    </div>
                </div>
            </div>

            <h3>üü° Object-Oriented Programming (Intermediate)</h3>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q6</span> What is the Rule of Three/Five/Zero?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>Rule of Three (C++98):</strong> If you define any of destructor, copy constructor, or copy assignment operator, you should define all three.</p>
                        <p><strong>Rule of Five (C++11):</strong> Add move constructor and move assignment operator to the list.</p>
                        <p><strong>Rule of Zero:</strong> Prefer using RAII types (smart pointers, containers) so you don't need to define any of these.</p>
<pre><code><span class="keyword">class</span> <span class="type">Resource</span> {
<span class="keyword">public</span>:
    <span class="comment">// Rule of Five</span>
    Resource();                                 <span class="comment">// Constructor</span>
    ~Resource();                                <span class="comment">// Destructor</span>
    Resource(<span class="keyword">const</span> Resource&);                 <span class="comment">// Copy constructor</span>
    Resource& <span class="keyword">operator</span>=(<span class="keyword">const</span> Resource&);      <span class="comment">// Copy assignment</span>
    Resource(Resource&&) <span class="keyword">noexcept</span>;             <span class="comment">// Move constructor</span>
    Resource& <span class="keyword">operator</span>=(Resource&&) <span class="keyword">noexcept</span>;  <span class="comment">// Move assignment</span>
};

<span class="comment">// Rule of Zero - preferred</span>
<span class="keyword">class</span> <span class="type">BetterResource</span> {
    std::unique_ptr&lt;<span class="keyword">int</span>[]&gt; data;  <span class="comment">// Smart pointer handles everything</span>
};</code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q7</span> What is virtual function and vtable?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p>A <strong>virtual function</strong> enables runtime polymorphism. When called through a base pointer/reference, the correct derived class method is invoked.</p>
                        <p>The <strong>vtable</strong> (virtual table) is a lookup table of function pointers. Each class with virtual functions has its own vtable. Objects contain a vptr (virtual pointer) pointing to their class's vtable.</p>
<pre><code><span class="keyword">class</span> <span class="type">Base</span> {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">speak</span>() { std::cout &lt;&lt; <span class="string">"Base"</span>; }
    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;  <span class="comment">// Virtual destructor!</span>
};

<span class="keyword">class</span> <span class="type">Derived</span> : <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">speak</span>() <span class="keyword">override</span> { std::cout &lt;&lt; <span class="string">"Derived"</span>; }
};

Base* ptr = <span class="keyword">new</span> Derived();
ptr->speak();  <span class="comment">// Output: "Derived" (dynamic dispatch)</span></code></pre>
                        <p><strong>Memory overhead:</strong> One vptr per object (8 bytes on 64-bit) + one vtable per class.</p>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q8</span> What is the diamond problem and how to solve it?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p>The <strong>diamond problem</strong> occurs in multiple inheritance when a class inherits from two classes that both inherit from a common base class, creating ambiguity.</p>
<pre><code><span class="keyword">class</span> <span class="type">A</span> { <span class="keyword">public</span>: <span class="keyword">int</span> value; };
<span class="keyword">class</span> <span class="type">B</span> : <span class="keyword">public</span> A { };
<span class="keyword">class</span> <span class="type">C</span> : <span class="keyword">public</span> A { };
<span class="keyword">class</span> <span class="type">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C { };  <span class="comment">// D has TWO copies of A!</span>

<span class="comment">// Solution: Virtual inheritance</span>
<span class="keyword">class</span> <span class="type">B</span> : <span class="keyword">virtual public</span> A { };
<span class="keyword">class</span> <span class="type">C</span> : <span class="keyword">virtual public</span> A { };
<span class="keyword">class</span> <span class="type">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C { };  <span class="comment">// D has ONE copy of A</span></code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q9</span> What is RAII and why is it important?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>RAII (Resource Acquisition Is Initialization)</strong> ties resource lifetime to object lifetime. Resources are acquired in constructor and released in destructor.</p>
<pre><code><span class="keyword">class</span> <span class="type">FileHandle</span> {
    FILE* file;
<span class="keyword">public</span>:
    <span class="function">FileHandle</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) : file(fopen(name, <span class="string">"r"</span>)) {
        <span class="keyword">if</span> (!file) <span class="keyword">throw</span> std::runtime_error(<span class="string">"Cannot open file"</span>);
    }
    <span class="function">~FileHandle</span>() { <span class="keyword">if</span> (file) fclose(file); }

    <span class="comment">// Delete copy operations</span>
    FileHandle(<span class="keyword">const</span> FileHandle&) = <span class="keyword">delete</span>;
    FileHandle& <span class="keyword">operator</span>=(<span class="keyword">const</span> FileHandle&) = <span class="keyword">delete</span>;
};

<span class="keyword">void</span> <span class="function">process</span>() {
    FileHandle fh(<span class="string">"data.txt"</span>);  <span class="comment">// File opened</span>
    <span class="comment">// ... use file ...</span>
}  <span class="comment">// File automatically closed, even if exception thrown</span></code></pre>
                        <p><strong>Benefits:</strong> Exception-safe, no resource leaks, deterministic cleanup.</p>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q10</span> Explain static keyword in different contexts.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
<pre><code><span class="comment">// 1. Static local variable - persists across function calls</span>
<span class="keyword">void</span> <span class="function">counter</span>() {
    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// Initialized once</span>
    count++;
}

<span class="comment">// 2. Static member variable - shared by all instances</span>
<span class="keyword">class</span> <span class="type">MyClass</span> {
    <span class="keyword">static</span> <span class="keyword">int</span> instanceCount;  <span class="comment">// Declaration</span>
};
<span class="keyword">int</span> MyClass::instanceCount = <span class="number">0</span>;  <span class="comment">// Definition (required)</span>

<span class="comment">// 3. Static member function - no 'this' pointer, can only access static members</span>
<span class="keyword">class</span> <span class="type">Utility</span> {
    <span class="keyword">static</span> <span class="keyword">int</span> <span class="function">helper</span>(<span class="keyword">int</span> x) { <span class="keyword">return</span> x * <span class="number">2</span>; }
};

<span class="comment">// 4. Static at file scope - internal linkage (visible only in this file)</span>
<span class="keyword">static</span> <span class="keyword">void</span> <span class="function">helperFunction</span>() { }  <span class="comment">// Not visible to other translation units</span></code></pre>
                    </div>
                </div>
            </div>

            <h3>üî¥ Advanced Topics</h3>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q11</span> What is move semantics and when should you use it?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>Move semantics</strong> allows transferring resources from one object to another without copying, using rvalue references (&&).</p>
<pre><code><span class="keyword">class</span> <span class="type">Buffer</span> {
    <span class="keyword">int</span>* data;
    <span class="keyword">size_t</span> size;
<span class="keyword">public</span>:
    <span class="comment">// Move constructor - "steals" resources</span>
    <span class="function">Buffer</span>(Buffer&& other) <span class="keyword">noexcept</span>
        : data(other.data), size(other.size) {
        other.data = <span class="keyword">nullptr</span>;  <span class="comment">// Leave source in valid state</span>
        other.size = <span class="number">0</span>;
    }
};

std::vector&lt;Buffer&gt; vec;
Buffer b(<span class="number">1000</span>);
vec.push_back(std::move(b));  <span class="comment">// Move instead of copy</span></code></pre>
                        <p><strong>Use when:</strong> Returning local objects, inserting into containers, transferring ownership.</p>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q12</span> Explain smart pointers: unique_ptr, shared_ptr, weak_ptr.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>Type</th><th>Ownership</th><th>Use Case</th></tr>
                            <tr><td><code>unique_ptr</code></td><td>Exclusive</td><td>Single owner, factory functions</td></tr>
                            <tr><td><code>shared_ptr</code></td><td>Shared (ref-counted)</td><td>Multiple owners needed</td></tr>
                            <tr><td><code>weak_ptr</code></td><td>Non-owning observer</td><td>Breaking cycles, caching</td></tr>
                        </table>
<pre><code><span class="comment">// unique_ptr - cannot be copied, only moved</span>
std::unique_ptr&lt;Widget&gt; w1 = std::make_unique&lt;Widget&gt;();
std::unique_ptr&lt;Widget&gt; w2 = std::move(w1);  <span class="comment">// w1 is now null</span>

<span class="comment">// shared_ptr - reference counted</span>
std::shared_ptr&lt;Widget&gt; s1 = std::make_shared&lt;Widget&gt;();
std::shared_ptr&lt;Widget&gt; s2 = s1;  <span class="comment">// ref count = 2</span>

<span class="comment">// weak_ptr - doesn't affect ref count</span>
std::weak_ptr&lt;Widget&gt; weak = s1;
<span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.lock()) {  <span class="comment">// Check if still alive</span>
    locked->doSomething();
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q13</span> What is SFINAE and how is it used?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>SFINAE (Substitution Failure Is Not An Error)</strong> - when template argument substitution fails, the compiler removes that overload from consideration instead of generating an error.</p>
<pre><code><span class="comment">// Enable function only for integral types</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type
<span class="function">process</span>(T value) {
    <span class="keyword">return</span> value * <span class="number">2</span>;
}

<span class="comment">// C++20 concepts are cleaner:</span>
<span class="keyword">template</span>&lt;std::integral T&gt;
T <span class="function">process</span>(T value) {
    <span class="keyword">return</span> value * <span class="number">2</span>;
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q14</span> What are the differences between new/delete and malloc/free?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>new/delete</th><th>malloc/free</th></tr>
                            <tr><td>Calls constructor/destructor</td><td>Only allocates/frees memory</td></tr>
                            <tr><td>Type-safe (returns correct type)</td><td>Returns void*, needs cast</td></tr>
                            <tr><td>Can be overloaded</td><td>Cannot be overloaded</td></tr>
                            <tr><td>Throws std::bad_alloc on failure</td><td>Returns NULL on failure</td></tr>
                            <tr><td>Size calculated automatically</td><td>Size must be specified</td></tr>
                        </table>
                        <p><strong>Rule:</strong> Never mix them! Use new with delete, malloc with free.</p>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q15</span> Explain the memory layout of a C++ object.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
<pre><code><span class="keyword">class</span> <span class="type">Example</span> {
    <span class="keyword">int</span> a;           <span class="comment">// 4 bytes</span>
    <span class="keyword">char</span> b;          <span class="comment">// 1 byte + 3 padding</span>
    <span class="keyword">double</span> c;        <span class="comment">// 8 bytes</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">foo</span>();  <span class="comment">// Adds vptr (8 bytes on 64-bit)</span>
};
<span class="comment">// Total: 8 (vptr) + 4 + 4 (padding) + 8 = 24 bytes</span></code></pre>
                        <p><strong>Layout includes:</strong></p>
                        <ul>
                            <li>vptr (if virtual functions exist) - usually at the beginning</li>
                            <li>Base class subobjects</li>
                            <li>Member variables (in declaration order)</li>
                            <li>Padding for alignment</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3>üü£ Expert Level</h3>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q16</span> What is the difference between std::atomic and mutex?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>std::atomic</th><th>std::mutex</th></tr>
                            <tr><td>Lock-free (usually)</td><td>Blocking</td></tr>
                            <tr><td>Single variable operations</td><td>Protects code sections</td></tr>
                            <tr><td>Lower overhead</td><td>Higher overhead</td></tr>
                            <tr><td>Limited operations</td><td>Any operations</td></tr>
                        </table>
<pre><code><span class="comment">// Atomic - for simple counters, flags</span>
std::atomic&lt;<span class="keyword">int</span>&gt; counter{<span class="number">0</span>};
counter++;  <span class="comment">// Thread-safe</span>

<span class="comment">// Mutex - for complex operations</span>
std::mutex mtx;
std::lock_guard&lt;std::mutex&gt; lock(mtx);
<span class="comment">// Multiple operations protected</span></code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q17</span> Explain template metaprogramming with an example.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p>Template metaprogramming performs computations at compile time using templates.</p>
<pre><code><span class="comment">// Compile-time factorial</span>
<span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;
<span class="keyword">struct</span> <span class="type">Factorial</span> {
    <span class="keyword">static constexpr</span> <span class="keyword">int</span> value = N * Factorial&lt;N-<span class="number">1</span>&gt;::value;
};

<span class="keyword">template</span>&lt;&gt;
<span class="keyword">struct</span> <span class="type">Factorial</span>&lt;<span class="number">0</span>&gt; {
    <span class="keyword">static constexpr</span> <span class="keyword">int</span> value = <span class="number">1</span>;
};

<span class="comment">// Usage - computed at compile time!</span>
<span class="keyword">constexpr</span> <span class="keyword">int</span> fact5 = Factorial&lt;<span class="number">5</span>&gt;::value;  <span class="comment">// 120</span>

<span class="comment">// Modern C++17 with constexpr if</span>
<span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;
<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="function">factorial</span>() {
    <span class="keyword">if constexpr</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">else</span> <span class="keyword">return</span> N * factorial&lt;N-<span class="number">1</span>&gt;();
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q18</span> What are C++20 Concepts and how do they improve templates?</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p>Concepts provide named constraints for template parameters, improving error messages and code clarity.</p>
<pre><code><span class="comment">// Define a concept</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">concept</span> Sortable = <span class="keyword">requires</span>(T a, T b) {
    { a &lt; b } -> std::convertible_to&lt;<span class="keyword">bool</span>&gt;;
    { a == b } -> std::convertible_to&lt;<span class="keyword">bool</span>&gt;;
};

<span class="comment">// Use the concept</span>
<span class="keyword">template</span>&lt;Sortable T&gt;
<span class="keyword">void</span> <span class="function">sort</span>(std::vector&lt;T&gt;& vec) { <span class="comment">/* ... */</span> }

<span class="comment">// Or with requires clause</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">requires</span> Sortable&lt;T&gt;
<span class="keyword">void</span> <span class="function">sort</span>(std::vector&lt;T&gt;& vec) { <span class="comment">/* ... */</span> }

<span class="comment">// Standard library concepts</span>
<span class="keyword">template</span>&lt;std::integral T&gt;  <span class="comment">// Only integral types</span>
T <span class="function">add</span>(T a, T b) { <span class="keyword">return</span> a + b; }</code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q19</span> What is undefined behavior? Give examples.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <p><strong>Undefined Behavior (UB)</strong> means the C++ standard imposes no requirements. The program may crash, produce wrong results, or appear to work.</p>
                        <p><strong>Common UB examples:</strong></p>
<pre><code><span class="comment">// 1. Dereferencing null/dangling pointer</span>
<span class="keyword">int</span>* p = <span class="keyword">nullptr</span>;
*p = <span class="number">5</span>;  <span class="comment">// UB!</span>

<span class="comment">// 2. Array out of bounds</span>
<span class="keyword">int</span> arr[<span class="number">5</span>];
arr[<span class="number">10</span>] = <span class="number">1</span>;  <span class="comment">// UB!</span>

<span class="comment">// 3. Signed integer overflow</span>
<span class="keyword">int</span> x = INT_MAX;
x++;  <span class="comment">// UB!</span>

<span class="comment">// 4. Use after free</span>
<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);
<span class="keyword">delete</span> p;
*p = <span class="number">10</span>;  <span class="comment">// UB!</span>

<span class="comment">// 5. Data race</span>
<span class="keyword">int</span> shared = <span class="number">0</span>;
<span class="comment">// Two threads writing without synchronization - UB!</span></code></pre>
                    </div>
                </div>
            </div>

            <div class="qa-item">
                <div class="question" onclick="this.parentElement.classList.toggle('active')">
                    <span><span class="question-number">Q20</span> Explain the difference between compile-time and runtime polymorphism.</span>
                </div>
                <div class="answer">
                    <div class="answer-content">
                        <table>
                            <tr><th>Compile-time (Static)</th><th>Runtime (Dynamic)</th></tr>
                            <tr><td>Templates, function overloading</td><td>Virtual functions</td></tr>
                            <tr><td>Resolved at compile time</td><td>Resolved at runtime via vtable</td></tr>
                            <tr><td>No runtime overhead</td><td>vtable lookup overhead</td></tr>
                            <tr><td>Code bloat (template instantiation)</td><td>Smaller code size</td></tr>
                        </table>
<pre><code><span class="comment">// Compile-time polymorphism (CRTP)</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;
<span class="keyword">class</span> <span class="type">Base</span> {
    <span class="keyword">void</span> <span class="function">interface</span>() {
        <span class="keyword">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)->impl();
    }
};

<span class="comment">// Runtime polymorphism</span>
<span class="keyword">class</span> <span class="type">Base</span> {
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="function">interface</span>() = <span class="number">0</span>;
};</code></pre>
                    </div>
                </div>
            </div>

            <!-- Quick Reference Questions -->
            <h3>üìù Quick Fire Questions</h3>
            <div class="topic-grid">
                <div class="topic-card">
                    <h5>Q21: What is ODR?</h5>
                    <p>One Definition Rule - each entity must have exactly one definition across all translation units.</p>
                </div>
                <div class="topic-card">
                    <h5>Q22: What is POD type?</h5>
                    <p>Plain Old Data - trivially copyable type compatible with C structs.</p>
                </div>
                <div class="topic-card">
                    <h5>Q23: What is aggregate initialization?</h5>
                    <p>Initializing arrays/structs with braces: <code>int arr[] = {1, 2, 3};</code></p>
                </div>
                <div class="topic-card">
                    <h5>Q24: What is copy elision?</h5>
                    <p>Compiler optimization that eliminates unnecessary copy/move operations (guaranteed in C++17).</p>
                </div>
                <div class="topic-card">
                    <h5>Q25: What is ADL?</h5>
                    <p>Argument-Dependent Lookup - function lookup includes namespaces of argument types.</p>
                </div>
                <div class="topic-card">
                    <h5>Q26: What is std::forward for?</h5>
                    <p>Perfect forwarding - preserves value category (lvalue/rvalue) when passing arguments.</p>
                </div>
            </div>

            <!-- Coding Challenges -->
            <h3>üíª Coding Challenges</h3>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Challenge 1: Implement a Thread-Safe Singleton</span>
                </div>
                <div class="collapsible-content">
<pre><code><span class="keyword">class</span> <span class="type">Singleton</span> {
<span class="keyword">private</span>:
    <span class="function">Singleton</span>() = <span class="keyword">default</span>;

<span class="keyword">public</span>:
    <span class="comment">// Delete copy/move operations</span>
    Singleton(<span class="keyword">const</span> Singleton&) = <span class="keyword">delete</span>;
    Singleton& <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&) = <span class="keyword">delete</span>;

    <span class="keyword">static</span> Singleton& <span class="function">getInstance</span>() {
        <span class="keyword">static</span> Singleton instance;  <span class="comment">// Thread-safe in C++11+</span>
        <span class="keyword">return</span> instance;
    }
};</code></pre>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Challenge 2: Implement make_unique (C++11 style)</span>
                </div>
                <div class="collapsible-content">
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
std::unique_ptr&lt;T&gt; <span class="function">make_unique</span>(Args&&... args) {
    <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...));
}

<span class="comment">// Usage</span>
<span class="keyword">auto</span> ptr = make_unique&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">42</span>);  <span class="comment">// vector of 10 42s</span></code></pre>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Challenge 3: Implement a Simple String Class</span>
                </div>
                <div class="collapsible-content">
<pre><code><span class="keyword">class</span> <span class="type">String</span> {
    <span class="keyword">char</span>* data_;
    <span class="keyword">size_t</span> size_;

<span class="keyword">public</span>:
    <span class="comment">// Constructor</span>
    <span class="function">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">""</span>)
        : size_(strlen(str)), data_(<span class="keyword">new</span> <span class="keyword">char</span>[size_ + <span class="number">1</span>]) {
        strcpy(data_, str);
    }

    <span class="comment">// Destructor</span>
    <span class="function">~String</span>() { <span class="keyword">delete</span>[] data_; }

    <span class="comment">// Copy constructor</span>
    <span class="function">String</span>(<span class="keyword">const</span> String& other)
        : size_(other.size_), data_(<span class="keyword">new</span> <span class="keyword">char</span>[size_ + <span class="number">1</span>]) {
        strcpy(data_, other.data_);
    }

    <span class="comment">// Move constructor</span>
    <span class="function">String</span>(String&& other) <span class="keyword">noexcept</span>
        : data_(other.data_), size_(other.size_) {
        other.data_ = <span class="keyword">nullptr</span>;
        other.size_ = <span class="number">0</span>;
    }

    <span class="comment">// Copy-and-swap idiom for assignment</span>
    String& <span class="keyword">operator</span>=(String other) {
        swap(*<span class="keyword">this</span>, other);
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="function">swap</span>(String& a, String& b) <span class="keyword">noexcept</span> {
        <span class="keyword">using</span> std::swap;
        swap(a.data_, b.data_);
        swap(a.size_, b.size_);
    }
};</code></pre>
                </div>
            </div>
        </section>

        <!-- ==================== RESOURCES SECTION ==================== -->
        <section id="resources">
            <h2>üìö Learning Resources</h2>

            <div class="info">
                <div>Curated collection of the best resources to continue your C++ learning journey.</div>
            </div>

            <h3>üìñ Recommended Books</h3>
            <div class="topic-grid">
                <div class="topic-card">
                    <h5>üü¢ Beginner</h5>
                    <ul>
                        <li><strong>C++ Primer</strong> - Lippman, Lajoie, Moo</li>
                        <li><strong>Programming: Principles and Practice</strong> - Bjarne Stroustrup</li>
                        <li><strong>A Tour of C++</strong> - Bjarne Stroustrup</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h5>üü° Intermediate</h5>
                    <ul>
                        <li><strong>Effective C++</strong> - Scott Meyers</li>
                        <li><strong>Effective Modern C++</strong> - Scott Meyers</li>
                        <li><strong>The C++ Standard Library</strong> - Nicolai Josuttis</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h5>üî¥ Advanced</h5>
                    <ul>
                        <li><strong>C++ Templates: The Complete Guide</strong> - Vandevoorde, Josuttis</li>
                        <li><strong>C++ Concurrency in Action</strong> - Anthony Williams</li>
                        <li><strong>Modern C++ Design</strong> - Andrei Alexandrescu</li>
                    </ul>
                </div>
            </div>

            <h3>üé¨ YouTube Channels</h3>
            <div class="video-grid">
                <div class="video-card">
                    <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                    <div class="video-info">
                        <h5>The Cherno</h5>
                        <p class="channel">Excellent C++ series for beginners to advanced</p>
                        <a href="https://www.youtube.com/@TheCherno" target="_blank" class="video-link">‚ñ∂ Visit Channel</a>
                    </div>
                </div>
                <div class="video-card">
                    <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                    <div class="video-info">
                        <h5>CppCon</h5>
                        <p class="channel">Official C++ conference talks</p>
                        <a href="https://www.youtube.com/@CppCon" target="_blank" class="video-link">‚ñ∂ Visit Channel</a>
                    </div>
                </div>
                <div class="video-card">
                    <div class="video-thumbnail"><span class="play-icon">‚ñ∂Ô∏è</span></div>
                    <div class="video-info">
                        <h5>Jason Turner</h5>
                        <p class="channel">C++ Weekly - short, focused episodes</p>
                        <a href="https://www.youtube.com/@caboricern" target="_blank" class="video-link">‚ñ∂ Visit Channel</a>
                    </div>
                </div>
            </div>

            <h3>üåê Online Resources</h3>
            <div class="topic-grid">
                <div class="topic-card">
                    <h5>üìù Documentation</h5>
                    <ul>
                        <li><a href="https://en.cppreference.com" target="_blank">cppreference.com</a> - Comprehensive reference</li>
                        <li><a href="https://isocpp.org" target="_blank">isocpp.org</a> - Official C++ site</li>
                        <li><a href="https://isocpp.github.io/CppCoreGuidelines/" target="_blank">C++ Core Guidelines</a></li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h5>üíª Practice Platforms</h5>
                    <ul>
                        <li><a href="https://leetcode.com" target="_blank">LeetCode</a> - Algorithm practice</li>
                        <li><a href="https://www.hackerrank.com/domains/cpp" target="_blank">HackerRank C++</a></li>
                        <li><a href="https://codeforces.com" target="_blank">Codeforces</a> - Competitive programming</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h5>üîß Tools</h5>
                    <ul>
                        <li><a href="https://godbolt.org" target="_blank">Compiler Explorer</a> - See assembly output</li>
                        <li><a href="https://quick-bench.com" target="_blank">Quick Bench</a> - Benchmark code</li>
                        <li><a href="https://cppinsights.io" target="_blank">C++ Insights</a> - See compiler transformations</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer>
            <div class="footer-content">
                <p>üöÄ <strong>C++ Mastery Guide</strong> - Your Complete Learning Companion</p>
                <p>Created with ‚ù§Ô∏è for the C++ community</p>
                <p class="footer-links">
                    <a href="https://github.com" target="_blank">‚≠ê Star on GitHub</a> |
                    <a href="#" onclick="window.scrollTo({top: 0, behavior: 'smooth'}); return false;">‚Üë Back to Top</a>
                </p>
                <p class="version">Version 1.0.0 | Last Updated: January 2026</p>
            </div>
        </footer>
    </main>

    <script>
        // ==================== JAVASCRIPT ====================

        // Theme Toggle - Fixed implementation
        const themeToggleBtn = document.querySelector('.theme-toggle');
        const themeIcon = document.querySelector('.theme-icon');
        const themeText = document.querySelector('.theme-text');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');

        function setTheme(isDark) {
            document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
            document.body.classList.toggle('dark-mode', isDark);
            if (themeIcon) themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            if (themeText) themeText.textContent = isDark ? 'Light' : 'Dark';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        // Global toggleTheme function for onclick handler
        function toggleTheme() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            setTheme(!isDark);
        }

        // Initialize theme on page load
        (function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                setTheme(savedTheme === 'dark');
            } else {
                setTheme(prefersDark.matches);
            }
        })();

        // Also add click listener as backup
        if (themeToggleBtn) {
            themeToggleBtn.addEventListener('click', toggleTheme);
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        // Initialize all collapsible sections
        function initCollapsibles() {
            const collapsibleHeaders = document.querySelectorAll('.collapsible-header');
            console.log('Found collapsible headers:', collapsibleHeaders.length);

            collapsibleHeaders.forEach((header, index) => {
                // Remove any existing listeners by cloning
                const newHeader = header.cloneNode(true);
                header.parentNode.replaceChild(newHeader, header);

                // Add click event listener
                newHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const collapsible = this.parentElement;
                    collapsible.classList.toggle('active');
                    console.log('Toggled collapsible:', index, collapsible.classList.contains('active'));
                });

                // Add keyboard accessibility
                newHeader.setAttribute('tabindex', '0');
                newHeader.setAttribute('role', 'button');
                newHeader.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });
            });
        }

        // Run when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCollapsibles);
        } else {
            initCollapsibles();
        }

        // Progress tracking
        function updateProgress() {
            const levels = ['beginner', 'intermediate', 'advanced'];
            let totalChecked = 0;
            let totalCheckboxes = 0;

            levels.forEach(level => {
                const checkboxes = document.querySelectorAll(`[data-level="${level}"] input[type="checkbox"]`);
                const checked = Array.from(checkboxes).filter(cb => cb.checked).length;
                const total = checkboxes.length;

                totalChecked += checked;
                totalCheckboxes += total;

                const progressBar = document.getElementById(`${level}Progress`);
                const progressText = document.getElementById(`${level}ProgressText`);

                if (progressBar && progressText && total > 0) {
                    const percentage = Math.round((checked / total) * 100);
                    progressBar.style.width = `${percentage}%`;
                    progressText.textContent = `${checked}/${total}`;
                }
            });

            // Update overall progress
            const overallBar = document.getElementById('overallProgress');
            const overallText = document.getElementById('overallProgressText');
            if (overallBar && overallText && totalCheckboxes > 0) {
                const percentage = Math.round((totalChecked / totalCheckboxes) * 100);
                overallBar.style.width = `${percentage}%`;
                overallText.textContent = `${percentage}%`;
            }

            // Save to localStorage
            saveProgress();
        }

        function saveProgress() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            const progress = {};
            checkboxes.forEach(cb => {
                if (cb.id) {
                    progress[cb.id] = cb.checked;
                }
            });
            localStorage.setItem('cppProgress', JSON.stringify(progress));
        }

        function loadProgress() {
            const saved = localStorage.getItem('cppProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                Object.keys(progress).forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) {
                        checkbox.checked = progress[id];
                    }
                });
            }
            updateProgress();
        }

        // Add event listeners to all checkboxes
        document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', updateProgress);
        });

        // Load saved progress on page load
        loadProgress();

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();

            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }

            const results = [];

            // Search in sections
            document.querySelectorAll('section').forEach(section => {
                const title = section.querySelector('h2')?.textContent || '';
                if (title.toLowerCase().includes(query)) {
                    results.push({
                        title: title,
                        type: 'Section',
                        element: section
                    });
                }
            });

            // Search in collapsible headers
            document.querySelectorAll('.collapsible-header span').forEach(header => {
                const text = header.textContent.toLowerCase();
                if (text.includes(query)) {
                    results.push({
                        title: header.textContent,
                        type: 'Topic',
                        element: header.closest('.collapsible')
                    });
                }
            });

            // Search in questions
            document.querySelectorAll('.question span').forEach(question => {
                const text = question.textContent.toLowerCase();
                if (text.includes(query)) {
                    results.push({
                        title: question.textContent.substring(0, 60) + '...',
                        type: 'Question',
                        element: question.closest('.qa-item')
                    });
                }
            });

            // Display results
            if (results.length > 0) {
                searchResults.innerHTML = results.slice(0, 8).map(r => `
                    <div class="search-result-item" data-id="${results.indexOf(r)}">
                        <span class="result-type">${r.type}</span>
                        <span class="result-title">${r.title}</span>
                    </div>
                `).join('');
                searchResults.style.display = 'block';

                // Add click handlers
                searchResults.querySelectorAll('.search-result-item').forEach((item, index) => {
                    item.addEventListener('click', () => {
                        const result = results[index];
                        result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        if (result.element.classList.contains('collapsible')) {
                            result.element.classList.add('active');
                        }
                        if (result.element.classList.contains('qa-item')) {
                            result.element.classList.add('active');
                        }
                        searchResults.style.display = 'none';
                        searchInput.value = '';
                    });
                });
            } else {
                searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
                searchResults.style.display = 'block';
            }
        });

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                searchResults.style.display = 'none';
            }
        });

        // Keyboard shortcut for search (Ctrl/Cmd + K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                searchResults.style.display = 'none';
                searchInput.blur();
            }
        });

        // Smooth scroll for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Copy code functionality
        document.querySelectorAll('pre').forEach(pre => {
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'üìã Copy';
            copyBtn.addEventListener('click', () => {
                const code = pre.querySelector('code')?.textContent || pre.textContent;
                navigator.clipboard.writeText(code).then(() => {
                    copyBtn.textContent = '‚úÖ Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = 'üìã Copy';
                    }, 2000);
                });
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Reset progress button
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                localStorage.removeItem('cppProgress');
                document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateProgress();
            }
        }

        console.log('üöÄ C++ Mastery Guide loaded successfully!');
        console.log('üìä Progress tracking enabled');
        console.log('üîç Search with Ctrl/Cmd + K');
    </script>
</body>
</html>
